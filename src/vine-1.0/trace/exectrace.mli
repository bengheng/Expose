(*
Vine is Copyright (C) 2006-2009, BitBlaze Team.

You can redistribute and modify it under the terms of the GNU GPL,
version 2 or later, but it is made available WITHOUT ANY WARRANTY.
See the top-level README file for more details.

For more information about Vine and other BitBlaze software, see our
web site at: http://bitblaze.cs.berkeley.edu/
*)

(** rewrite assignments to post_vars as conditional jumps,
    such that execution will jump straight to a FAIL node
    as soon as a post_var is not satisfied.
    @param post_var variable for the final post-condition
    @param stmt_block Vine Block to examine
    @return rewritten Vine Block
*)
val post_vars_to_cjmps : Vine.var -> Vine.stmt -> Vine.stmt

val varset_of_prog : Vine.program -> Vine.VarSet.t
val gamma_of_varset : Vine.var -> Vine.VarSet.t -> Asmir.varctx
val flatten_blocks : Vine.program -> Vine.program

type trace_insn = {
  label : Vine.label;
  cmt : string;
  asm_dl : Vine.decl list;
  asm_sl : Vine.stmt list;
  setup_ir : Vine.stmt list;
  tainted_eflags : bool; (* XXX should get this from temu interface *)
} ;;

type trace_prog = {
  use_thunks : bool;
  arch : Asmir.arch;
  gamma : Asmir.varctx;
  dl : Vine.decl list;
  mems_arrays : (Vine.decl * Vine.decl) list;
  prog_setup_ir : Vine.stmt list
} ;;


type filter_application = trace_prog -> trace_insn option -> 
  Temu_trace.instruction -> int64 -> trace_prog * trace_insn option

class type eh_filter =
object
  method apply : filter_application
end

type disasm_context = {
   mutable prog : trace_prog;
   mutable r_insns : trace_insn list;
   filters : eh_filter list;
} ;;

(** creates a disassembly context that stores all program info as a trace is 
  disassembled using a trace_fold function *)
val create_disasm_ctx : 
  ?use_thunks : bool -> 
  ?gammaparam : Asmir.varctx option -> 
  eh_filter list ->
  disasm_context

(** disassembles one instruction from the trace as part of trace folding *)
val handle_eh : 
  disasm_context -> 
  Temu_trace.instruction -> 
  int64 -> 
  disasm_context


(** opens a trace, processes each instruction with the list of
    filter objects, and returns the list of processed instructions
    and global information about the program.
    @param stop_addr optional, stop processing at this PC
    @param use_thunks optional, call eflag thunks instead of inlining
    them.
    @param tracename file name of trace to be processed
    @param filters list of filter objects to apply to each instruction
*)
val disasm_trace :
  ?stop_l:(Libasmir.address_t*int) list ->
  ?start_ctr:int64 ->
  ?stop_ctr:int64 ->
  ?use_thunks:bool ->
  ?gammaparam:Asmir.varctx option ->
  string -> 
  eh_filter list -> trace_prog * trace_insn list

(** Take the output of disasm_trace and create an IR program.
    @param deend optional, deendianize all memory accesses.
    you MUST use this to deendianize the trace, rather than
    doing a separate deendianization pass. This uses info
    in trace_prog to make sure that memory variable names
    are consistent.
    @param trace_prog global info about the trace, generated by
    disasm_trace
    @param trace_insns list of processed instructions, generated
    by disasm_trace
*)
val trace_to_prog : 
  ?deend:bool ->
  trace_prog -> trace_insn list -> Vine.program

(** disassembles instructions that operate on tainted data *)
class disasm_tainted : eh_filter

(** disassembles all instructions *)
class disasm_all : eh_filter

(** set a flag controlling how de-endianization is performed, both in
    the deend_filter and elsewhere in exectrace. When false, convert
    memories into a single array of bytes. When true, convert into
    multiple arrays for different-sized accesses.
*)
val deend_use_multi : bool -> unit

(** set a flag controlling whether de-endianization will be performed, 
    everywhere in exectrace except in the deend_filter. When false,
    don't do de-endianization. When true (default), do de-endianization.
*)
val deend_use : bool -> unit

(** deendianize asm and filter IR *)
class deend_filter : eh_filter

(** trace filter: add initializer statements to beginning 
    @deprecated This has been broken into several smaller filters.
    see initialize_operands_small, initialize_input_symbols,
    check_expected_values_filter, and track_opval_filter.
*)
class initialize_operands : bool -> bool -> eh_filter

(** add assertions to constrain memory accesses of tainted indices
    are within the memory ranges specified in the instruction
    operands, or within the provided static_valid_ranges
*)
class constrain_mem_accesses : (int64 * int64) list -> eh_filter

(** remove asserts added by constrain_mem_accesses filter.
    this is a temporary hack to get the concretized indexes
    provided by the constrain_mem_accesses filter without 
    the asserts. 
    WARNING: resulting IR is UNSOUND
*)
class remove_mem_constraints : eh_filter

class constrain_mem_accesses_tattrs : (int64 * int64) list -> eh_filter

(** trace filter: rewrite to straightline, adding asserts *)
class make_straightline_filter : eh_filter

(**
   use evaluator to rewrite all Mem exps to have concrete index.
   @param prog program to rewrite
   @return program with concrete memory indices
*)
class conc_idx_filter : eh_filter

(** print each instruction (for debugging) *)
class print_filter : eh_filter

(** rewrite labels to ensure uniqueness. currently implemented
    by appending the entry-header-number to each label.
*)
class uniqify_labels : eh_filter 

(** trace filter: handle outsw instructions.
    rep outsw's are translated to decrement ECX appropriately.
    outsw's are dropped.
*)
class handle_outsw: eh_filter

(** tracks what symbolic values and locations have been seen.
    used as a common resource by other filters. 
    when using this filter with other filters that depend on it,
    make sure this one is BEFORE the others.
*)
class track_opval_filter :
object
  method apply : filter_application

  method prev_initd_locs_mem : Temu_trace.operand -> int -> bool
  method prev_input_vars_mem : Int32.t -> Int32.t -> bool
  method input_vars_var : Int32.t -> Int32.t -> Vine.var
  method input_vars_val : Int32.t -> Int32.t -> Int64.t
end

(** initializes instruction operands concretely or symbolically.
    Needs a track_opval_filter object, which must execute BEFORE
    this one in the filter list given to disasm_trace *)
class initialize_operands_small : 
  track_opval_filter -> bool -> eh_filter

(** variation of initialize_operands_small that creates
    a fresh symbol after a missed propagation.
    XXX FIXME: initialize_input_symbols currently won't initialize
    these symbols.
*)
(* class initialize_operands_small_fresh_symbols :  *)
(*   track_opval_filter -> bool -> eh_filter *)

(** 
    initialize input symbols to the concrete value from the trace on
    the first instruction involving a particular input byte. 
    Needs a track_opval_filter object, which must execute BEFORE
    this one in the filter list given to disasm_trace 
*)
class initialize_input_symbols : 
  track_opval_filter -> eh_filter

(** for Register operands with some fresh symbolic values,
    and no propagated symbolic values,
    zero out the register. this makes dependency analysis easier
    by making it clear that the value of the register does not
    depend on any previous statements
    Needs a track_opval_filter object, which must execute BEFORE
    this one in the filter list given to disasm_trace.
*)
class break_dep_chains_filter :
  track_opval_filter -> eh_filter

class rewrite_mem_by_pid :
  Vine.typ -> eh_filter

(** removes instructions that VEX/Vine do not currently support.
    Removing an instruction from the IR can have unexpected consequences, 
    but sometimes is the only way to continue some analysis
    Use with care!
*)
class unknowns_filter : eh_filter

  
(**** some post-processing utilities *****)

val asserts_to_post : Vine.program -> Vine.program * Vine.var
val create_assert_variable : Vine.program -> Vine.program
val prop_constants : Vine.program -> bool -> Vine.program

(* cut-paste-and-modify. ick *)
(* val mems_to_tmps : Vine.program -> Vine.program *)

(** utilities for working directly with temu trace *)
module Reg_x86 :
  sig
    type regid =
        Reg_es
      | Reg_cs
      | Reg_ss
      | Reg_ds
      | Reg_fs
      | Reg_gs
      | Reg_eAX
      | Reg_eCX
      | Reg_eDX
      | Reg_eBX
      | Reg_eSP
      | Reg_eBP
      | Reg_eSI
      | Reg_eDI
      | Reg_al
      | Reg_cl
      | Reg_dl
      | Reg_bl
      | Reg_ah
      | Reg_ch
      | Reg_dh
      | Reg_bh
      | Reg_ax
      | Reg_cx
      | Reg_dx
      | Reg_bx
      | Reg_sp
      | Reg_bp
      | Reg_si
      | Reg_di
      | Reg_eax
      | Reg_ecx
      | Reg_edx
      | Reg_ebx
      | Reg_esp
      | Reg_ebp
      | Reg_esi
      | Reg_edi
      | Reg_indir_dx
    val regid_of_addr : int64 -> regid
    val regid_to_str : regid -> string
    val regid_to_full : regid -> regid
    val regid_to_write_mask : regid -> int64
    val regid_to_read_mask : regid -> int64
    val regid_to_type : regid -> Vine.typ
    val canon_reg_offset : regid -> int -> regid * int
    val write_reg : Asmir.varctx -> regid -> Vine.exp -> int -> Vine.stmt
    val read_reg : Asmir.varctx -> regid -> Vine.exp
    val read_reg_byte : Asmir.varctx -> regid -> int -> Vine.exp
    val opcode : char array -> int * int
    val is_call : char array -> bool
    val is_ret : char array -> bool
    val uses_esp : char array -> bool
  end

module Opval :
  sig
    val vine_t :
      < opaddr : int64; oplen : int; optype : Temu_trace.opType; .. > -> Vine.typ
    val byte_foldleft :
      ('a -> Temu_trace.operand -> int -> 'a) -> Temu_trace.operand -> 'a -> 'a
    val byte_tainted : < taintflag : int64; .. > -> int -> bool
    val byte_map : (Temu_trace.operand -> int -> 'a) -> Temu_trace.operand -> 'a list
    val byte_conc_val : < opvalue : int32; .. > -> int -> Int64.t
    val byte_exp :
      Asmir.varctx ->
      < opaddr : int64; optype : Temu_trace.opType; .. > -> int -> Vine.exp
    val exp :
      Asmir.varctx ->
      < opaddr : int64; oplen : int; optype : Temu_trace.opType; .. > -> Vine.exp
    val const :
      < opaddr : int64; oplen : int; optype : Temu_trace.opType;
        opvalue : Int32.t; .. > ->
      Vine.exp
    val byte_mov :
      Asmir.varctx ->
      < opaddr : int64; optype : Temu_trace.opType; .. > ->
      int -> Vine.exp -> Vine.stmt
    val mov :
      Asmir.varctx ->
      < opaddr : int64; oplen : int; optype : Temu_trace.opType; .. > ->
      Vine.exp -> Vine.stmt
    val to_string : < opaddr : int64; optype : Temu_trace.opType; .. > -> string
  end
