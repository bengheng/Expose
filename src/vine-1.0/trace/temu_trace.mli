(*
Vine is Copyright (C) 2006-2009, BitBlaze Team.

You can redistribute and modify it under the terms of the GNU GPL,
version 2 or later, but it is made available WITHOUT ANY WARRANTY.
See the top-level README file for more details.

For more information about Vine and other BitBlaze software, see our
web site at: http://bitblaze.cs.berkeley.edu/
*)

(**
   An interface to execution traces generated by TEMU.
*)

(** Type of operands *)
type opType =
  | TNone               (** Invalid operands *)
  | TRegister           (** Register operands *)
  | TMemLoc             (** Memory operands *)
  | TImmediate          (** Immediate value *)
  | TJump               (** Jump targets *)
  | TFloatRegister      (** Floating point register *)
  | TMemAddress         (** Uninitialized memory, as seen in LEA *)

type opUsage =
  | UUnknown
  | UEsp
  | UCounter
  | UMemBase
  | UMemIndex
  | UMemSegment
  | UMemSegent0
  | UMemSegent1

type opAccess =
  | A_Unknown
  | A_RW      (* Read and written (must write) *)
  | A_R       (* Read-only *)
  | A_W       (* Write-only (must write) *)
  | A_RCW     (* Read and conditionally write (may write) *)
  | A_CW      (* Conditionally written (may write) *)
  | A_CRW     (* Conditionally read, always written (must write) *)
  | A_CR      (* Conditionally read *)

(** Type of taint propagtion
  The value indicates if the instruction needs to be included in
  the IR and why.
    TPUnknown: this trace does not support TP
    TPNone: the instruction does not need to be included in the IR
      since it did not propagate taint info
    TPSrc: one src operand was tainted. Thus the dst becomes tainted
      Common in moves where the src is tainted and in arithmetic ops
    TPCjmp: conditional jump that uses a tainted eflag
    TPMemReadIndex: memory read using a tainted index for the src
    TPMemWriteIndex: memory write using a tainted index for the dst
    TPRepCounter: instruction with rep prefix and tainted counter

  NOTE: the order of the types is significant, since currently
    an instruction only has one of this types associated (rather than a list).
    Since an instruction could need to set several of these types,
    then we need to assign some precedence.
    The precedence is given by the lowest in the following list.
    Thus, TPMemWriteIndex would take precedence over TPSrc and
    TPRepCounter would take precedence over TPMemWriteIndex.

    For example, for mov %eax,(%ecx) where both %eax and %ecx are tainted,
    then the value for this instruction will be TPMemWriteIndex,
    rather than TPSrc, since it appears lower in this list.
*)
type taintProp =
  | TPUnknown
  | TPNone
  | TPSrc
  | TPCjmp
  | TPMemReadIndex
  | TPMemWriteIndex
  | TPRepCounter


(** Exception for traces with an unknown version number in the header *)
exception Unknown_trace_version
(** Exception for traces with no header *)
exception No_trace_header
(** Exception for operations that require an index file but not provided *)
exception No_index

(** Class for instruction operands *)
class virtual operand :
object
  (** Get type of operand *)
  method virtual optype : opType

  (** Get length of operand 
      v30 and v10 traces will always return 4 for non-register operands *)
  method virtual oplen : int

  (** Get operand address. For register operands, it is the register number;
      for memory operands, it is the memory address; for immediate and
      jump targets, it is set to zero *)
  method virtual opaddr : Libasmir.address_t

  (** Get operand access (read/write/...). Added with operand_v50 *)
  method virtual opaccess : opAccess

  (** Get operand value *)
  method virtual opvalue : Int32.t

  (** Get dynamic taint flag *)
  method virtual taintflag : Int64.t

  (** Get origin of tainted operand
      The first element of the array specifies the origin of the least
      significant byte of the operand, and so on*)
  method virtual origin : Int32.t array

  (** Get offset
      The first element of the array specifies the offset of the least
      significant byte of the operand, and so on*)
  method virtual offset : Int32.t array

  method virtual serialize : unit IO.output -> unit

  method virtual unserialize : IO.input -> unit
end

(** Class for an instruction *)
class virtual instruction :
object

  (** Get process ID *)
  method virtual pid : int

  (** Get instruction pointer *)
  method virtual address : Libasmir.address_t

  (** Get raw instruction *)
  method virtual rawbytes : char array

  (** Get array of operands. When an instruction has multiple operands,
      the first one (arg 0) is destination, as is in Intel syntax *)
  method virtual operand : operand array

  (** Get more details of memory operand.
      If an operand is a memory cell, the corresponding memregs array
      specifies segment, base, index, scale, and offset*)
  method virtual memregs : operand array array

  (** Get stack pointer ESP *)
  method virtual esp : operand

  (** Get CPU flags EFLAGS *)
  method virtual eflags : Int32.t

  (** Get CC_OP *)
  method virtual cc_op : Int32.t

  (** Get df *)
  method virtual df : Int32.t

  (** Get HFLAGS *)
  method virtual hflags : Int32.t

  (** Get ldt register value *)
  method virtual ldt : Int32.t

  (** Get gdt register value *)
  method virtual gdt : Int32.t

  (** Get tr *)
  method virtual tr : Int32.t

  (** Get idt register value *)
  method virtual idt : Int32.t

  (** Write an instruction to the output steam *)
  method virtual serialize : unit IO.output -> unit

  (** Read an instruction from input steam *)
  method virtual unserialize : IO.input -> unit

  (** Get instruction size value. Added with instruction_v40 *)
  method virtual inst_size : int

  (** Get number of operands in instruction. Added with instruction_v40
      The count does not include ESP but it includes all others such as:
	src, dst, memory addressing, TJump, and TFloatRegister operands *)
  method virtual num_operands : int

  (** Get taint propagation value. Added with instruction_v40 *)
  method virtual tp : taintProp

  (** Get thread id for the instruction. Added with instruction_v40 *)
  method virtual thread_id : Int32.t

end

(** The trace header *)
type traceHeader = {
  magicnumber : int32;
  version : int;
  n_procs : int;
  gdt_base : Libasmir.address_t;
  idt_base : Libasmir.address_t;
}

(** Information of a module (such as dynamic library) in a process *)
class mod_info :
object

  (** Module name *)
  method name : string

  (** Module base address in memory *)
  method base : Int64.t

  (** Module size *)
  method size : Int64.t

  method serialize : unit IO.output -> unit

  method unserialize : IO.input -> unit

end

(** Information about a process in the trace *)
class proc_info : int ->
object

  (** Process name *)
  method name : string

  (** Process ID *)
  method pid  : int

  (** List of modules in this process *)
  method modules : mod_info list

  (** Read a process record from the given channel *)
  method serialize : unit IO.output -> unit

  (** Write a process record to the given channel *)
  method unserialize : IO.input -> unit

  (** List of modules in this process. Added in version 50 *)
  method ldt_base : Libasmir.address_t

end

(** Class for trace interface *)
class trace_interface :
  traceHeader ->
  in_channel ->
  proc_info list ->
  (IO.input -> instruction) ->
object
  method channel : in_channel

  method iochannel : IO.input

  (** Offset of the first instruction in a trace file *)
  method insn_offset : int64

  (** Offset of the current instruction *)
  method current_offset : unit -> int64

  (** Clean up *)
  method cleanup : unit

  (** Get trace version *)
  method version : int

  (** Get process list *)
  method processes : proc_info list

  (** Set the index array used to random access instructions in a trace *)
  method set_index : in_channel -> unit

  (** After seek_instruction i, next read_instruction will get the ith
      instruction. Note that i starts from 1, not 0 
      Raises No_index if no trace index is available *)
  method seek_instruction : int64 -> unit

  (** Return the number of instructions in the trace. 
        Returns zero if not supported *)
  method num_instructions : int64

  (** Read the next instruction from the trace file *)
  method read_instruction : instruction

  method write_header : unit IO.output -> unit

  method insn_counter : int64
end

(** Iterate over entries in a trace. Analagous to List.fold_left *)
val trace_fold : ('a -> instruction -> int64 -> 'a) -> 'a
  -> trace_interface
  -> 'a

(** Iterate over entries in a trace in reverse order. 
  Analagous to List.fold_right
  Requires a trace index for random access to the trace. 
  Raises No_index if the no index is available for the trace
*)
val trace_fold_right : ('a -> instruction -> int64 -> 'a) -> 'a
  -> trace_interface
  -> 'a

(** Iterate over entries in a trace in reverse order, starting at given 
      instruction. 
  Requires a trace index for random access to the trace. 
  Raises No_index if the no index is available for the trace
*)
val trace_fold_right_from_ctr : int64 -> ('a -> instruction -> int64 -> 'a) 
  -> 'a -> trace_interface -> 'a

(** 
[trace_fold_until_addr addr l f a ti] is similar to trace_fold but 
  but stops iterating when any of the termination conditions is satisfied.
  Each termination condition is specified as an [(addr,ctr)] pair, where
    the termination condition is satisfied if address [addr] is reached 
    a number [ctr] of times.
  The instruction that first satisfies a termination condition is not 
    included in the trace.
  Values 0 and 1 for [ctr] behave identically
*)
val trace_fold_until_addr :
  (Libasmir.address_t * int) list -> ('a -> instruction -> int64 -> 'a) -> 'a -> trace_interface -> 'a

(** [trace_fold_until_ctr max_ctr f a ti] is like trace_fold,
    but stops upon processing max_ctr instructions (inclusive). *)
val trace_fold_until_ctr :
  int64 -> ('a -> instruction -> int64 -> 'a) -> 'a -> trace_interface -> 'a

val trace_fold_from_until_ctr :
  int64 -> int64 -> ('a -> instruction -> int64 -> 'a) -> 'a -> trace_interface -> 'a

(** Opens trace file
    @param tname Trace file name
    @return Trace file input channel, trace format version, and number of
    processes in the trace
    @raise Unknown_trace_version for unsupported trace versions
*)
val open_trace: string -> trace_interface

(** Closes trace file
    @param tc Trace file input channel
*)
val close_trace: trace_interface -> unit

(** Convert an unsigned 32-bit interger into a 64-bit one
*)
val int64_of_uint32: Int32.t -> Int64.t

(** Convert the optype into a corresponding string
*)
val optype_str: opType -> string

(** Read the trace header from an IO.input and return the
    version and the number of processes in a int pair
*)
val read_header: IO.input -> traceHeader

(** Read the information from one process from trace
*)
val read_process: int -> IO.input -> proc_info

(** Convert opType type to string *)
val optype_str : opType -> string

(** Convert opUsage type to string *)
val opusage_str : opUsage -> string

(** Convert taintProp type to string *)
val taintprop_str : taintProp -> string

(** Print a virtual type operand *)
val print_virtual_operand : out_channel -> operand -> unit

(** Print a virtual type instruction *)
val print_virtual_insn : out_channel -> instruction -> unit

type taintByteRecord = {
  source: Int32.t;
  origin: Int32.t;
  offset: Int32.t;
}

type taintRecord = {
  taint_propag: int; (* -1 in versions >= v50 *)
  num_records: int;
  taint_bytes: taintByteRecord array;
}

(* ============================= v20 ============================= *)
(** Class for instruction v20 operands *)
class operand_v20 :
object
  (* Interface methods *)
  method optype : opType
  method opaccess : opAccess
  method opaddr : Libasmir.address_t
  method oplen : int
  method opvalue : Int32.t
  method taintflag : Int64.t
  method origin : Int32.t array
  method offset : Int32.t array
  method serialize : unit IO.output -> unit
  method unserialize : IO.input -> unit
  (* Additional methods *)
  (* Get operand taint records *)
  method records : taintRecord array
end

class instruction_v20 :
object
  (* Interface methods *)
  method pid : int
  method address : Libasmir.address_t
  method rawbytes : char array
  method operand : operand array
  method memregs : operand array array
  method esp : operand
  method eflags : Int32.t
  method cc_op : Int32.t
  method df : Int32.t
  method hflags : Int32.t
  method ldt : Int32.t
  method gdt : Int32.t
  method tr : Int32.t
  method idt : Int32.t
  method serialize : unit IO.output -> unit
  method unserialize : IO.input -> unit
  method inst_size : int
  method num_operands : int
  method tp : taintProp
  method thread_id : Int32.t

  (* Additional methods *)
  (* Get the instruction opcode *)
  method opcode : int array
  (* Get the instruction prefixes *)
  method prefixes : Int32.t
  (* Get the instruction modrm *)
  method modrm : int
  (* Get the instruction operands as type operand_v20 array *)
  method operand_or : operand_v20 array
  (* Get the instruction esp operand as type operand_v20 *)
  method esp_or : operand_v20
end


(* ============================= v30 ============================= *)
(** Class for instruction v30 operands *)
class operand_v30 :
object
  (* Interface methods *)
  method optype : opType
  method opaccess : opAccess
  method opaddr : Libasmir.address_t
  method oplen : int
  method opvalue : Int32.t
  method taintflag : Int64.t
  method origin : Int32.t array
  method offset : Int32.t array
  method serialize : unit IO.output -> unit
  method unserialize : IO.input -> unit
  method srcid: int32 array
  method newid: char array
end

class instruction_v30 :
object
  (* Interface methods *)
  method size : int
  method pid : int
  method address : Libasmir.address_t
  method rawbytes : char array
  method operand : operand array
  method memregs : operand array array
  method esp : operand
  method eflags : Int32.t
  method cc_op : Int32.t
  method df : Int32.t
  method hflags : Int32.t
  method ldt : Int32.t
  method gdt : Int32.t
  method tr : Int32.t
  method idt : Int32.t
  method serialize : unit IO.output -> unit
  method unserialize : IO.input -> unit
  method operand_v30 : operand_v30 array
  method inst_size : int
  method num_operands : int
  method tp : taintProp
  method thread_id : Int32.t
end

(* ============================= v40 ============================= *)
(** Class for instruction v40 operands *)
class operand_v40 :
object
  (* Interface methods *)
  method optype : opType
  method opusage : opUsage
  method opaccess : opAccess
  method opaddr : Libasmir.address_t
  method oplen : int
  method opvalue : Int32.t
  method taintflag : Int64.t
  method origin : Int32.t array
  method offset : Int32.t array
  method serialize : unit IO.output -> unit
  method unserialize : IO.input -> unit
  (* Additional methods *)
  (* Get operand taint records *)
  method records : taintRecord array
end

class instruction_v40 :
object
  (* Interface methods *)
  method pid : int
  method address : Libasmir.address_t
  method rawbytes : char array
  method operand : operand array
  method memregs : operand array array
  method esp : operand
  method eflags : Int32.t
  method cc_op : Int32.t
  method df : Int32.t
  method hflags : Int32.t
  method ldt : Int32.t
  method gdt : Int32.t
  method tr : Int32.t
  method idt : Int32.t
  method serialize : unit IO.output -> unit
  method unserialize : IO.input -> unit
  method inst_size : int
  method num_operands : int
  method tp : taintProp
  method thread_id : Int32.t
  (* Additional methods *)
  (* Get the instruction operands as type operand_v20 array *)
  method operand_or : operand_v40 array
  (* Get the instruction esp operand as type operand_v20 *)
  method esp_or : operand_v40
end

(* ============================= v41 ============================= *)
(** Class for instruction v41 operands *)
class operand_v41 :
object
  (* Interface methods *)
  method optype : opType
  method opusage : opUsage
  method opaccess : opAccess
  method opaddr : Libasmir.address_t
  method oplen : int
  method opvalue : Int32.t
  method taintflag : Int64.t
  method origin : Int32.t array
  method offset : Int32.t array
  method serialize : unit IO.output -> unit
  method unserialize : IO.input -> unit
  (* Additional methods *)
  (* Get operand taint records *)
  method records : taintRecord array
end

class instruction_v41 :
object
  (* Interface methods *)
  method pid : int
  method address : Libasmir.address_t
  method rawbytes : char array
  method operand : operand array
  method memregs : operand array array
  method esp : operand
  method eflags : Int32.t
  method cc_op : Int32.t
  method df : Int32.t
  method hflags : Int32.t
  method ldt : Int32.t
  method gdt : Int32.t
  method tr : Int32.t
  method idt : Int32.t
  method serialize : unit IO.output -> unit
  method unserialize : IO.input -> unit
  method inst_size : int
  method num_operands : int
  method tp : taintProp
  method thread_id : Int32.t
  (* Additional methods *)
  (* Get the instruction operands as type operand_v20 array *)
  method operand_or : operand_v41 array
  (* Get the instruction esp operand as type operand_v20 *)
  method esp_or : operand_v41
end

(* ============================= v50 ============================= *)
(** Class for instruction v50 operands *)
class operand_v50 :
object
  (* Interface methods *)
  method optype : opType
  method opusage : opUsage
  method opaccess : opAccess
  method opaddr : Libasmir.address_t
  method oplen : int
  method opvalue : Int32.t
  method taintflag : Int64.t
  method origin : Int32.t array
  method offset : Int32.t array
  method serialize : unit IO.output -> unit
  method unserialize : IO.input -> unit
  (* Additional methods *)
  (* Get operand taint records *)
  method records : taintRecord array
end

class instruction_v50 :
object
  (* Interface methods *)
  method pid : int
  method address : Libasmir.address_t
  method rawbytes : char array
  method operand : operand array
  method memregs : operand array array
  method esp : operand
  method eflags : Int32.t
  method cc_op : Int32.t
  method df : Int32.t
  method hflags : Int32.t
  method ldt : Int32.t
  method gdt : Int32.t
  method tr : Int32.t
  method idt : Int32.t
  method serialize : unit IO.output -> unit
  method unserialize : IO.input -> unit
  method inst_size : int
  method num_operands : int
  method tp : taintProp
  method thread_id : Int32.t
  (* Additional methods *)
  (* Get the instruction operands as type operand_v20 array *)
  method operand_or : operand_v50 array
  (* Get the instruction esp operand as type operand_v20 *)
  method esp_or : operand_v50
  (* Set the instruction _idt field *)
  method set_idt : Libasmir.address_t -> unit
  (* Set the instruction _gdt field *)
  method set_gdt : Libasmir.address_t -> unit
  (* Set the instruction _ldt field *)
  method set_ldt : Libasmir.address_t -> unit
end


