(*
Vine is Copyright (C) 2006-2009, BitBlaze Team.

You can redistribute and modify it under the terms of the GNU GPL,
version 2 or later, but it is made available WITHOUT ANY WARRANTY.
See the top-level README file for more details.

For more information about Vine and other BitBlaze software, see our
web site at: http://bitblaze.cs.berkeley.edu/
*)

(**
   An interface to program state files generated by TEMU. 
*)

open Vine

module D = Debug.Make(struct let name="temu_state" and default=`NoDebug end)

exception Unknown_state_version

(* Magic number for state files *)
let sMAGIC_NUMBER = 0xFFFEFFFEl

type userRegs = {
  eax : int32; 
  ebx : int32; 
  ecx : int32; 
  edx : int32; 
  esi : int32; 
  edi : int32; 
  ebp : int32; 
  esp : int32; 
  eip : int32;
  eflags : int32; 
  xcs : int32; 
  xds : int32; 
  xes : int32; 
  xfs : int32;
  xgs : int32; 
  xss : int32; 
}

(* A block (i.e., range) of addresses.
    (both first and last addresses belong to the block 
*)
type block = {
  first : Libasmir.address_t; 
  last  : Libasmir.address_t; 
  pos : int64; 
}


(** Class for state interface *)
class state_interface version channel io_channel regs block_l =
object(self)
  val _version : int = version
  val _rawchannel : in_channel = channel
  val _iochannel : IO.input = io_channel
  val _curr_offset : int64 = LargeFile.pos_in channel
  val _regs : userRegs = regs
  val _block_l : block list = block_l
  val _num_blocks = List.length block_l
  method version = _version
  method blocks = _block_l
  method num_blocks = _num_blocks
  method regs = _regs
  method private channel = _rawchannel
  method private iochannel = _iochannel
  method private current_offset () = LargeFile.pos_in _rawchannel

  (* Cleanup *)
  method cleanup =
    IO.close_in _iochannel;
    close_in_noerr _rawchannel;

  (* Obtain values from memory block (reads from file) *)
  method get_memrange first last =
    let process_block (in_blk,acc) blk =
      let first_blk = (first >= blk.first) && (first <= blk.last) in
      let in_blk = first_blk || in_blk in
      if in_blk then (
        let last_blk = (last >= blk.first) && (last <= blk.last) in
        (* Get first address *)
        let first_addr =
          if (first_blk) then first
          else blk.first
        in
        (* Get last address *)
        let last_addr =
          if (last_blk) then last
          else blk.last
        in
        (* Get file position to start reading *)
        let first_pos =
          let offset = Int64.sub first_addr blk.first in
          Int64.add blk.pos offset
        in
        (* Get size to read *)
        let size =
          Int64.to_int (Int64.succ (Int64.sub last_addr first_addr))
        in
        (* Position file pointer *)
        let () = LargeFile.seek_in _rawchannel first_pos in
        (* Read data as string *)
        let blk_str = IO.nread _iochannel size in
        (* Convert string into list of integers *)
        let blk_l = ExtString.String.explode blk_str in
	(* Create pairs (address,value) *)
	let process_byte (idx,acc2) byteval = 
	  let addr = Int64.add first_addr idx in
	  (Int64.succ idx,(addr,byteval) :: acc2)
	in
	let (_,pair_l) = List.fold_left process_byte (0L,[]) blk_l in
        (* Append list *)
        ((not last_blk),(List.rev_append pair_l acc))
      )
      else (false,acc)
    in
    let (_,l) = List.fold_left process_block (false,[]) _block_l in
    l

  (* Generate range inits from state file *)
  method range_inits ranges memvar =
    List.fold_left
      (fun mem_inits (first,last) ->
	 let data = self#get_memrange first last in
	 let mem_inits =
	   List.fold_left
	     (fun mem_inits (addr,byte) ->
		let lhs = Mem(memvar,
			      const_of_int64 addr_t addr,
			      REG_8) in
		let rhs = const_of_int REG_8 (int_of_char byte) in
		Move(lhs,rhs)::mem_inits
	     )
	     mem_inits
	     data
	 in
	 mem_inits
      )
      []
      ranges

  (* Generate a hashtable (Libasmir.address_t -> char) for all bytes in the
       range. Missing bytes in the state file do not appear in the table. *)
  method private get_memrange_tbl first last =

    (* Create hashtbl *)
    let range_size = 
      Int64.to_int (Int64.succ (Int64.sub last first)) 
    in
    let tbl = Hashtbl.create range_size in

    (* Iterate over all blocks in state file *)
    let process_block in_range blk =
      let first_blk = (first >= blk.first) && (first <= blk.last) in
      let in_range = first_blk || in_range in
      if in_range then (
        let last_blk = (last >= blk.first) && (last <= blk.last) in
        (* Get first address *)
        let first_addr =
          if (first_blk) then first
          else blk.first
        in
        (* Get last address *)
        let last_addr =
          if (last_blk) then last
          else blk.last
        in
        (* Get file position to start reading *)
        let first_pos =
          let offset = Int64.sub first_addr blk.first in
          Int64.add blk.pos offset
        in
        (* Get size to read *)
        let size =
          Int64.to_int (Int64.succ (Int64.sub last_addr first_addr))
        in
        (* Position file pointer *)
        let () = LargeFile.seek_in _rawchannel first_pos in
        (* Read data as string *)
        let blk_str = IO.nread _iochannel size in
        (* Convert string into list of integers *)
        let blk_l = ExtString.String.explode blk_str in
        (* Create pairs (address,value) *)
        let process_byte idx byteval =
          let addr = Int64.add first_addr idx in
          Hashtbl.replace tbl addr byteval;
          Int64.succ idx
        in
        let _ = List.fold_left process_byte 0L blk_l in
        (not last_blk)
      )
      else false
    in
    let _ = List.fold_left process_block false _block_l in
    tbl

  (* Apply given function to values of all byte in range. 
     Missing values in state file are filled with fill_char *)
  method iter_range ?(fill_char=(Char.chr 0x90)) f first last =
    let tbl = self#get_memrange_tbl first last in
    let rec process_byte curr_addr = 
      if curr_addr > last then ()
      else (
        let () = 
          try (
            let char_val = Hashtbl.find tbl curr_addr in
            f curr_addr char_val
          )
          with Not_found -> f curr_addr fill_char
        in
        process_byte (Int64.succ curr_addr)
      )
    in
    process_byte first


  (* Write values of range into given IO output channel
     Missing values in state file are filled with fill_char *)
  method write_range ?(fill_char=(Char.chr 0x90)) oc first last =
    self#iter_range ~fill_char:fill_char 
      (fun _ c -> output_char oc c) 
      first last

end


(* Read register list from IO channel (v10) *)
let read_registers_v10 io = 
  let ebx = IO.read_real_i32 io in
  let ecx = IO.read_real_i32 io in
  let edx = IO.read_real_i32 io in
  let esi = IO.read_real_i32 io in
  let edi = IO.read_real_i32 io in
  let ebp = IO.read_real_i32 io in
  let eax = IO.read_real_i32 io in 
  let xds = IO.read_real_i32 io in
  let xes = IO.read_real_i32 io in
  let xfs = IO.read_real_i32 io in
  let xgs = IO.read_real_i32 io in
  let _ = IO.read_real_i32 io in (* orig_eax not in user_regs *)
  let eip = IO.read_real_i32 io in
  let xcs = IO.read_real_i32 io in
  let eflags = IO.read_real_i32 io in
  let esp = IO.read_real_i32 io in
  let xss = IO.read_real_i32 io in
    { eax = eax; ebx = ebx; ecx = ecx; edx = edx;
      esi = esi; edi = edi; ebp = ebp; esp = esp;
      eip = eip; eflags = eflags; xcs = xcs; xds = xds;
      xes = xes; xfs = xfs; xgs = xgs; xss = xss; }

(* Read register list from IO channel (v20) *)
let read_registers_v20 io =
  let ebx = IO.read_real_i32 io in
  let ecx = IO.read_real_i32 io in
  let edx = IO.read_real_i32 io in
  let esi = IO.read_real_i32 io in
  let edi = IO.read_real_i32 io in
  let ebp = IO.read_real_i32 io in
  let eax = IO.read_real_i32 io in
  let xds = IO.read_real_i32 io in
  let xes = IO.read_real_i32 io in
  let xfs = IO.read_real_i32 io in
  let xgs = IO.read_real_i32 io in
  let _ = IO.read_real_i32 io in (* orig_eax not in user_regs *)
  let eip = IO.read_real_i32 io in
  let xcs = IO.read_real_i32 io in
  let eflags = IO.read_real_i32 io in
  let esp = IO.read_real_i32 io in
  let xss = IO.read_real_i32 io in
    { eax = eax; ebx = ebx; ecx = ecx; edx = edx;
      esi = esi; edi = edi; ebp = ebp; esp = esp;
      eip = eip; eflags = eflags; xcs = xcs; xds = xds;
      xes = xes; xfs = xfs; xgs = xgs; xss = xss; }


(* Read list of blocks in input channel (v10) *)
let read_blocks_v10 ic io = 
  let read_block io =
    let first = Int64.of_int32 (IO.read_real_i32 io) in
    let last = Int64.pred (Int64.of_int32 (IO.read_real_i32 io)) in
    let pos = LargeFile.pos_in ic in
    let blocksize = Int64.succ (Int64.sub last first) in
    let () = LargeFile.seek_in ic (Int64.add pos blocksize) in
    {first = first; last = last; pos = pos;}
  in
  let rec read_all_blocks io =
    try 
      let blk = read_block io in
	blk :: read_all_blocks io
    with 
	IO.No_more_input 
      | End_of_file -> []
  in
    read_all_blocks io

(* Read list of blocks in input channel (v20) *)
let read_blocks_v20 ic io =
  let read_block io =
    let first = Int64.of_int32 (IO.read_real_i32 io) in
    let last = Int64.of_int32 (IO.read_real_i32 io) in
    let pos = LargeFile.pos_in ic in
    let blocksize = Int64.succ (Int64.sub last first) in
    let () = LargeFile.seek_in ic (Int64.add pos blocksize) in
    {first = first; last = last; pos = pos;}
  in
  let rec read_all_blocks io =
    try
      let blk = read_block io in
        blk :: read_all_blocks io
    with
        IO.No_more_input
      | End_of_file -> []
  in
    read_all_blocks io

(* Print block *)
let print_block oc block = 
  Printf.fprintf oc "0x%08Lx -> 0x%08Lx (%Ld)\n%!" 
    block.first block.last block.pos

(* Print registers *)
let print_regs oc regs = 
  Printf.fprintf oc "EAX: 0x%08lx\n" regs.eax;
  Printf.fprintf oc "EBX: 0x%08lx\n" regs.ebx;
  Printf.fprintf oc "ECX: 0x%08lx\n" regs.ecx;
  Printf.fprintf oc "EDX: 0x%08lx\n" regs.edx;
  Printf.fprintf oc "ESI: 0x%08lx\n" regs.esi;
  Printf.fprintf oc "EDI: 0x%08lx\n" regs.edi;
  Printf.fprintf oc "EBP: 0x%08lx\n" regs.ebp;
  Printf.fprintf oc "ESP: 0x%08lx\n" regs.esp;
  Printf.fprintf oc "EIP: 0x%08lx\n" regs.eip;
  Printf.fprintf oc "EFLAGS: 0x%08lx\n" regs.eflags;
  Printf.fprintf oc "CS: 0x%08lx\n" regs.xcs;
  Printf.fprintf oc "DS: 0x%08lx\n" regs.xds;
  Printf.fprintf oc "ES: 0x%08lx\n" regs.xes;
  Printf.fprintf oc "FS: 0x%08lx\n" regs.xfs;
  Printf.fprintf oc "GS: 0x%08lx\n" regs.xgs;
  Printf.fprintf oc "SS: 0x%08lx\n" regs.xss;
  flush oc


(* Open state file and obtain state interface 
   Raises: Unknown_state_version *)
let open_state filename =
  let ic = open_in filename in
  let io = IO.input_channel ic in
  (* Read version *)
  let version = 
    let magic = IO.read_real_i32 io in
    if (magic = sMAGIC_NUMBER) then IO.read_i32 io
    else 
      let () = seek_in ic 0 in
      10
  in
  (* Process different versions *)
  (* File pointer will be at end of file after this *)
  match version with
    | 10 ->
        (* Read registers *)
        let regs = read_registers_v10 io in
        (* Read blocks in file *)
        let blocks = read_blocks_v10 ic io in
	  new state_interface version ic io regs blocks
    | 20 ->
        (* Read registers *)
        let regs = read_registers_v20 io in
        (* Read blocks in file *)
        let blocks = read_blocks_v20 ic io in
	  new state_interface version ic io regs blocks
    | _ ->
       raise Unknown_state_version


(* Close state file *)
let close_state state_iface =
  state_iface#cleanup


(* Add initializers for given memory region to given program *)
let add_range_inits_to_prog prog ranges memvar state_iface =
  let (dl,sl) = prog in 
  let mem_inits = state_iface#range_inits ranges memvar in
  (dl, Block([],mem_inits)::sl)

(* Generate range inits for given range *)
let generate_range_inits filename ranges memvar =
  let sif = open_state filename in
  let inits_l = sif#range_inits ranges memvar in
  let () = close_state sif in
  inits_l
  
