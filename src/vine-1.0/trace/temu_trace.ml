(*
Vine is Copyright (C) 2006-2009, BitBlaze Team.

You can redistribute and modify it under the terms of the GNU GPL,
version 2 or later, but it is made available WITHOUT ANY WARRANTY.
See the top-level README file for more details.

For more information about Vine and other BitBlaze software, see our
web site at: http://bitblaze.cs.berkeley.edu/
*)

(**
   An interface to execution traces generated by TEMU.
*)

type opType =
  | TNone
  | TRegister
  | TMemLoc
  | TImmediate
  | TJump
  | TFloatRegister
  | TMemAddress

type opUsage =
  | UUnknown
  | UEsp
  | UCounter
  | UMemBase
  | UMemIndex
  | UMemSegment
  | UMemSegent0
  | UMemSegent1

type opAccess = 
  | A_Unknown
  | A_RW      (* Read and written (must write) *)
  | A_R       (* Read-only *)
  | A_W       (* Write-only (must write) *)
  | A_RCW     (* Read and conditionally write (may write) *)
  | A_CW      (* Conditionally written (may write) *)
  | A_CRW     (* Conditionally read, always written (must write) *)
  | A_CR      (* Conditionally read *)

type taintProp =
  | TPUnknown
  | TPNone
  | TPSrc
  | TPCjmp
  | TPMemReadIndex
  | TPMemWriteIndex
  | TPRepCounter

type traceHeader = {
  magicnumber : int32;
  version : int;
  n_procs : int;
  gdt_base : Libasmir.address_t;
  idt_base : Libasmir.address_t;
}

exception Invalid_parameter of string
exception No_index
exception Unknown_trace_version

(** Class for instruction operands *)
class virtual operand =
object
  method virtual optype : opType
  method virtual opaccess : opAccess
  method virtual oplen : int
  method virtual opaddr : Libasmir.address_t
  method virtual opvalue : Int32.t
  method virtual taintflag : Int64.t
  method virtual origin : Int32.t array
  method virtual offset : Int32.t array

  method virtual serialize : unit IO.output -> unit
  method virtual unserialize : IO.input -> unit
end

(** Class for an instruction *)
class virtual instruction =
object
  method virtual pid : int
  method virtual address : Libasmir.address_t
    (* TODO: rawbytes would be better as a string, which would save on memory,
       since a char array stores a whole word (4 or 8 bytes) for every char. *)
  method virtual rawbytes : char array
  method virtual operand : operand array
  method virtual memregs : operand array array
  method virtual esp : operand
  method virtual eflags : Int32.t
  method virtual cc_op : Int32.t
  method virtual df : Int32.t
  method virtual hflags : Int32.t
  method virtual ldt : Int32.t
  method virtual gdt : Int32.t
  method virtual tr : Int32.t
  method virtual idt : Int32.t
  method virtual serialize : unit IO.output -> unit
  method virtual unserialize : IO.input -> unit
  method virtual inst_size : int
  method virtual num_operands : int
  method virtual tp : taintProp
  method virtual thread_id : Int32.t

end


(* Get string for optype *)
let optype_str = function
  | TNone -> "TNone"
  | TRegister -> "TRegister"
  | TMemLoc -> "TMemLoc"
  | TImmediate -> "TImmediate"
  | TJump -> "TJump"
  | TFloatRegister -> "TFloatRegister"
  | TMemAddress -> "TMemAddres"

(* Get string for opusage *)
let opusage_str = function
  | UUnknown -> "UUnknown"
  | UEsp -> "UEsp"
  | UCounter -> "UCounter"
  | UMemBase -> "UMemBase"
  | UMemIndex -> "UMemIndex"
  | UMemSegment -> "UMemSegment"
  | UMemSegent0 -> "UMemSegent0"
  | UMemSegent1 -> "UMemSegent1"

(* Get string for opaccess *)
let opaccess_str = function
  | A_Unknown -> "A_Unknown"
  | A_RW -> "A_RW"
  | A_R -> "A_R"
  | A_W -> "A_W"
  | A_RCW -> "A_RCW"
  | A_CW -> "A_CW"
  | A_CRW -> "A_CRW"
  | A_CR -> "A_CR"


(* Get string for taintProp *)
let taintprop_str = function
  | TPUnknown -> "TPUnknown"
  | TPNone -> "TPNone"
  | TPSrc -> "TPSrc"
  | TPCjmp -> "TPCjmp"
  | TPMemReadIndex -> "TPMemReadIndex"
  | TPMemWriteIndex -> "TPMemWriteIndex"
  | TPRepCounter -> "TPRepCounter"


(* Get register length in bytes from register address *)
let reglen_of_addr x =
  match x with
  (* 8-bit registers *)
  | 116L | 117L | 118L | 119L | 120L | 121L | 122L | 123L -> 1
  (* 16-bit registers *)
  | 124L | 125L | 126L | 127L | 128L | 129L | 130L | 131L
  (* segment registers (also 16-bit) *)
  | 100L | 101L | 102L | 103L | 104L | 105L -> 2
  (* 32-bit registers *)
  | 132L | 133L | 134L | 135L | 136L | 137L | 138L | 139L -> 4
  (* address-modifier dependent registers *)
  | 108L | 109L | 110L | 111L | 112L | 113L | 114L | 115L
  (* Reg_indir_dx *)
  | 150L
  (* ??? *)
  | _ -> raise (Invalid_parameter
    ("Unknown operand length:"^(Int64.to_string x)))

(** Convert an unsigned 32-bit interger into a 64-bit one
*)
let int64_of_uint32 x =
  Int64.logand
    (Int64.of_int32 x)
    0x00000000ffffffffL

let rec read_list acc f n =
  match n with
    | 0 -> acc
    | _ -> read_list ((f ()) :: acc) f (n-1)

let read_array f n =
  Array.of_list (List.rev (read_list [] f n))

let write_array f t=
  Array.fold_left f () t

let string_of_array t =
  let buildstr acc ch =
    match ch with
	'\000' -> acc
      | _ -> acc ^ (ExtString.String.of_char ch)
  in
    Array.fold_left buildstr "" t

(* Print virtual operand *)
let print_virtual_operand oc op = 
  if (op#optype <> TNone) then (
    Printf.fprintf oc "\tOP_TYPE: %s\n" (optype_str op#optype);
    Printf.fprintf oc "\tOP_LEN: %d\n" op#oplen;
    Printf.fprintf oc "\tOP_ADDR: 0x%08Lx\n" op#opaddr;
    Printf.fprintf oc "\tOP_VAL: 0x%lx\n" op#opvalue;
    Printf.fprintf oc "\tOP_TAINTED: %Lx\n" op#taintflag;
    let print_taint_info i origin =
      Printf.fprintf oc "\t\tIND: %d ORIGIN: %ld OFFSET: %ld\n"
	i origin op#offset.(i)
    in
    Array.iteri print_taint_info op#origin;
    Printf.fprintf oc "\n"
  )
  else ()

let print_virtual_insn oc eh =
  Printf.fprintf oc "\n";
  Printf.fprintf oc "EIP: %Lx\n" eh#address;
  Printf.fprintf oc "PID: %d\n" eh#pid;
  Printf.fprintf oc "Thread_ID: %ld\n" eh#thread_id;
  Printf.fprintf oc "Instruction size: %d\n" eh#inst_size;
  Printf.fprintf oc "Num Operands: %d\n" eh#num_operands;
  Printf.fprintf oc "TP: %s\n" (taintprop_str eh#tp);
  (* Not printing: eflags, cc_op, df, hflags, ldt, gdt, tr, idt *)
  (*
  Printf.fprintf "RAWBYTES: 0x";
  for i=0 to (self#inst_size - 1) do
    Printf.fprintf "%02x" (Char.code self#rawbytes.(i));
  done;
    Printf.fprintf "\n";
  *)
  (* Print ESP operand *)
  Printf.fprintf oc "ESP:\n";
  print_virtual_operand oc eh#esp;
  (* Print normal operands *)
  let print_op oc idx op = 
    Printf.fprintf oc "Op: %d\n" idx;
    print_virtual_operand oc op;
  in
  Array.iteri (print_op oc) eh#operand;
  (* Print memreg operands *)
  let print_memreg oc idx op =
    for j=0 to 2 do
      Printf.fprintf oc "Memreg: %d %d\n" idx j;
      print_virtual_operand oc eh#memregs.(idx).(j)
    done;
  in
  Array.iteri (print_memreg oc) eh#operand;
  Printf.fprintf oc "\n"

(* Taint records used by versions 20 and 40 *)
type taintByteRecord = {
  source: Int32.t;
  origin: Int32.t;
  offset: Int32.t;
}

type taintRecord = {
  taint_propag: int;
  num_records: int;
  taint_bytes: taintByteRecord array;
}

let empty_tbr = { source = 0l; origin = 0l; offset = 0l }
let empty_tr =
  { taint_propag = 0;num_records = 0;taint_bytes = Array.make 4 empty_tbr }

(* =========== BEGIN: Trace version 50  ======================= *)
class operand_v50 =
object (self)
  inherit operand
  val mutable _optype: opType = TNone
  val mutable _opusage: opUsage = UUnknown
  val mutable _opaccess : opAccess = A_Unknown
  val mutable _oplen: int = 0
  val mutable _opaddr: Libasmir.address_t = 0L
  val mutable _opvalue: Int32.t = 0l
  val mutable _taintflag: Int64.t = 0L
  val mutable _records: taintRecord array = [||]
  (* These two fields defined for compatibility *)
  val mutable _origin: Int32.t array = [||]
  val mutable _offset: Int32.t array = [||]
  (* Interface methods *)
  method optype = _optype
  method opaccess = _opaccess
  method oplen = _oplen
  method opaddr = _opaddr
  method opvalue = _opvalue
  method taintflag = _taintflag
  method origin = _origin
  method offset = _offset
  (* Additional methods *)
  method records = _records
  method opusage = _opusage

  method private read_taint_byte_record ic =
    let source = IO.read_real_i32 ic in
    let origin = IO.read_real_i32 ic in
    let offset = IO.read_real_i32 ic in
    {
      source = source;
      origin = origin;
      offset = offset;
    }

  method private write_taint_byte_record oc tbr =
    IO.write_real_i32 oc tbr.source;
    IO.write_real_i32 oc tbr.origin;
    IO.write_real_i32 oc tbr.offset

  method private read_taint_record ic =
    let num_records = IO.read_byte ic in
    let taint_bytes_arr =
	read_array (fun () -> self#read_taint_byte_record ic) num_records
    in
    assert (num_records <= 3);
    let empty_taint_bytes_arr = Array.make (3 - num_records) empty_tbr in
    {
      taint_propag = -1;
      num_records = num_records;
      taint_bytes = Array.append taint_bytes_arr empty_taint_bytes_arr;
    }

  method private write_taint_record oc tr =
    IO.write_byte oc tr.num_records;
    for i = 0 to (tr.num_records - 1) do
      self#write_taint_byte_record oc tr.taint_bytes.(i)
    done

  method private read_records ic oplen optaint =
    assert(oplen <= 8); (* Maximum number of bytes in operand *)
    let records_arr = Array.make oplen empty_tr in
    for i = 0 to (oplen - 1) do
      if ((Int64.logand optaint (Int64.of_int (1 lsl i))) <> 0L) then (
	Array.set records_arr i (self#read_taint_record ic)
      )
    done;
    records_arr

  method private write_records oc oplen optaint =
    for i = 0 to (oplen - 1) do
      if ((Int64.logand optaint (Int64.of_int (1 lsl i))) <> 0L) then (
	self#write_taint_record oc _records.(i)
      )
    done;

  method private get_origin records =
    let reclist = Array.to_list records in
    let add_origin l tr = tr.taint_bytes.(0).origin :: l in
    let origin_list = List.fold_left add_origin [] reclist in
    let origin_list = List.rev origin_list in
    Array.of_list origin_list

  method private get_offset records =
    let reclist = Array.to_list records in
    let add_offset l tr = tr.taint_bytes.(0).offset :: l in
    let offset_list = List.fold_left add_offset [] reclist in
    let offset_list = List.rev offset_list in
    Array.of_list offset_list

  method serialize oc =
    let rawoptype =
      match _optype with
          TNone -> 0
        | TRegister -> 1
        | TMemLoc -> 2
        | TImmediate -> 3
        | TJump -> 4
        | TFloatRegister -> 5
        | TMemAddress ->6
    in
    let rawopusage =
      match _opusage with
        | UUnknown -> 0
        | UEsp -> 1
        | UCounter -> 2
        | UMemBase -> 3
        | UMemIndex -> 4
        | UMemSegment -> 5
        | UMemSegent0 -> 6
        | UMemSegent1 -> 7
    in
    let rawopaccess = 
      match _opaccess with
	| A_Unknown -> 0
	| A_RW -> 1
	| A_R -> 2
	| A_W -> 3
	| A_RCW -> 4
	| A_CW -> 5
	| A_CRW -> 6
	| A_CR -> 7
    in
    let addr = Int64.to_int32 _opaddr in
      IO.write_byte oc rawopaccess;
      IO.write_byte oc _oplen;
      IO.write_ui16 oc (Int64.to_int _taintflag);
      IO.write_real_i32 oc addr;
      IO.write_real_i32 oc _opvalue;
      IO.write_byte oc rawoptype;
      IO.write_byte oc rawopusage;
      self#write_records oc _oplen _taintflag;

  method unserialize ic =
    let num_to_optype = function
        | 0 -> TNone
        | 1 -> TRegister
        | 2 -> TMemLoc
        | 3 -> TImmediate
        | 4 -> TJump
        | 5 -> TFloatRegister
        | 6 -> TMemAddress
        | _ -> TNone
    in
    let num_to_opusage = function
        | 0 -> UUnknown
        | 1 -> UEsp
        | 2 -> UCounter
        | 3 -> UMemBase
        | 4 -> UMemIndex
        | 5 -> UMemSegment
        | 6 -> UMemSegent0
        | 7 -> UMemSegent1
        | _ -> UUnknown
    in
    let num_to_opaccess = function
	| 0 -> A_Unknown
	| 1 -> A_RW
	| 2 -> A_R
	| 3 -> A_W
	| 4 -> A_RCW
	| 5 -> A_CW
	| 6 -> A_CRW
	| 7 -> A_CR
	| _ -> A_Unknown
    in
    let oa = num_to_opaccess (IO.read_byte ic) in
    let len = IO.read_byte ic in
    let tn = Int64.of_int (IO.read_ui16 ic) in
    let ad = int64_of_uint32 (IO.read_real_i32 ic) in
    let vl = IO.read_real_i32 ic in
    let ot = num_to_optype (IO.read_byte ic) in
    let ou = num_to_opusage (IO.read_byte ic) in
    let records = self#read_records ic len tn in
    let og = self#get_origin records in
    let os = self#get_offset records in
      _optype <- ot;
      _opusage <- ou;
      _opaccess <- oa;
      _oplen <- len;
      _opaddr <- ad;
      _opvalue <- vl;
      _taintflag <- tn;
      _records <- records;
      _origin <- og;
      _offset <- os;
end

class instruction_v50 =
object (self)
  inherit instruction
  val mutable _addr: Libasmir.address_t = 0L
  val mutable _tid: Int32.t = 0l
  val mutable _inst_size: int = 0
  val mutable _num_operands: int = 0
  val mutable _tp: taintProp = TPUnknown
  val mutable _rawbytes: char array = [||]
  val mutable _operand: operand_v50 array = [||]
  val mutable _memregs: operand_v50 array array = [||]
  val mutable _esp: operand_v50 = new operand_v50
  val mutable _eflags: Int32.t = 0l
  val mutable _cc_op: Int32.t = 0l
  val mutable _df: Int32.t = 0l
  val _hflags: Int32.t = 0l
  val mutable _ldt: Int32.t = 0l
  val mutable _gdt: Int32.t = 0l
  val _tr: Int32.t = 0l
  val mutable _idt: Int32.t = 0l
  (* Auxiliary methods *)
  method private create_operand op_arr =
    let add_operand op = (op : operand_v50 :> operand) in
    Array.map add_operand op_arr
  method private create_memregs op_arr_arr =
    let add_memreg mr = self#create_operand mr in
    Array.map add_memreg op_arr_arr
  (* Interface methods *)
  method pid = 0
  method address = _addr
  method rawbytes = _rawbytes
  method operand = self#create_operand _operand
  method memregs = self#create_memregs _memregs
  method esp = (_esp : operand_v50 :> operand)
  method eflags = _eflags
  method cc_op = _cc_op
  method df = _df
  method hflags = _hflags
  method ldt = _ldt
  method gdt = _gdt
  method tr = _tr
  method idt = _idt
  method inst_size = _inst_size
  method num_operands = _num_operands
  method tp = _tp
  method thread_id = _tid
  (* Additional methods *)
  method operand_or = _operand
  method esp_or = _esp
  method set_ldt x = _ldt <- (Int64.to_int32 x)
  method set_gdt x = _gdt <- (Int64.to_int32 x)
  method set_idt x = _idt <- (Int64.to_int32 x)

  method serialize oc =
    let write_tp oc =
      let tp_int =
        match _tp with
          | TPNone -> 0
          | TPSrc -> 1
          | TPCjmp -> 2
          | TPMemReadIndex -> 3
          | TPMemWriteIndex -> 4
          | TPRepCounter -> 5
          | TPUnknown -> failwith "Cannot write TPUnknown"
      in
      IO.write_byte oc tp_int
    in

    let write_operands oc op_arr memreg_arr =
      let num_ops = Array.length op_arr in
      for i = 0 to num_ops - 1 do
        let op = Array.get op_arr i in
        if (op#optype <> TNone) then (
          op#serialize oc;
          if ((op#optype = TMemLoc) || (op#optype = TMemAddress)) then (
            for j = 0 to 4 do
              let memreg = Array.get (Array.get memreg_arr i) j in
              if (memreg#optype <> TNone) then memreg#serialize oc;
            done;
          )
        )
      done
    in
    let write_rawbytes oc =
      let raw_rb = Array.sub _rawbytes 0 _inst_size in
      write_array (fun () ch -> IO.write oc ch) raw_rb
    in
    let addr = Int64.to_int32 _addr in
      IO.write_real_i32 oc addr;
      IO.write_real_i32 oc _tid;
      IO.write_ui16 oc _inst_size;
      IO.write_byte oc _num_operands;
      write_tp oc;
      IO.write_real_i32 oc _eflags;
      IO.write_real_i32 oc _cc_op;
      IO.write_real_i32 oc _df;
      write_rawbytes oc;
      write_operands oc _operand _memregs

  method unserialize ic =
    let read_tp ic =
      let tp_int = IO.read_byte ic in
      match tp_int with
        | 0 -> TPNone
        | 1 -> TPSrc
        | 2 -> TPCjmp
        | 3 -> TPMemReadIndex
        | 4 -> TPMemWriteIndex
        | 5 -> TPRepCounter
        | 6 -> TPNone (* Sysenter gets converted into TPNone *)
        | _ -> TPUnknown
    in
    let read_operand ic =
      let opr = new operand_v50 in
      let () = opr#unserialize ic in
        opr
    in
    let read_operands ic num_op =
      (* Read the list of operands from the file *)
      let all_op_l =
	List.rev (read_list [] (fun () -> read_operand ic) num_op) 
      in
      (* Set _esp operand if accessed by instruction *)
      let is_esp_op op = 
        (op#optype = TRegister) && (op#opaddr = 136L)
      in
      let _ = 
        try (
	  let esp_op = List.find is_esp_op all_op_l in
	  _esp <- esp_op
	)
	with Not_found -> ()
      in
      (* Obtain the number of normal operands (non-memregs/non-esp) *)
      let is_special_op op = 
          match op#opusage with
            | UCounter | UUnknown | UEsp-> false
            | _ -> true
      in
      let process_op acc op = 
	if (is_special_op op) then acc else acc + 1
      in
      let num_normal_ops = List.fold_left process_op 0 all_op_l in
      (* Create arrays *)
      let empty_operand = new operand_v50 in
      let op_arr = Array.make num_normal_ops empty_operand in
      let memreg_arr = 
	Array.make_matrix num_normal_ops 5 empty_operand 
      in
      if (num_op > 0) then (
        let process_operand i op =
          match op#opusage with
            | UMemBase ->
                Array.set (memreg_arr.(i-1)) 1 op; i
            | UMemIndex ->
                Array.set (memreg_arr.(i-1)) 2 op; i
            | UMemSegment ->
                Array.set (memreg_arr.(i-1)) 0 op; i
            | UMemSegent0 ->
                Array.set (memreg_arr.(i-1)) 3 op; i
            | UMemSegent1 ->
                Array.set (memreg_arr.(i-1)) 4 op; i
            | _ ->
                Array.set op_arr i op; i+1
        in
        let _ = List.fold_left process_operand 0 all_op_l in
        (op_arr,memreg_arr)
      )
      else (op_arr,memreg_arr)
    in
    let read_rawbytes ic is =
      let raw_rb = read_array (fun () -> IO.read ic) is in
      let empty_arr = Array.make (15 - is) (Char.chr 0) in
      Array.append raw_rb empty_arr
    in
    let ad = int64_of_uint32 (IO.read_real_i32 ic) in
    let ti = IO.read_real_i32 ic in
    let is = IO.read_ui16 ic in
    let no = IO.read_byte ic in
    let tp = read_tp ic in
    let ef = IO.read_real_i32 ic in
    let co = IO.read_real_i32 ic in
    let adf = IO.read_real_i32 ic in
    let rb = read_rawbytes ic is in

    let (op,mr) = read_operands ic no in
      _addr <- ad;
      _tid <- ti;
      _inst_size <- is;
      _num_operands <- no;
      _tp <- tp;
      _eflags <- ef;
      _cc_op <- co;
      _df <- adf;
      _operand <- op;
      _memregs <- mr;
      _rawbytes <- rb;
end

(* =========== BEGIN: Trace version 41  ======================= *)
class operand_v41 =
object (self)
  inherit operand
  val mutable _optype: opType = TNone
  val mutable _opusage: opUsage = UUnknown
  val _opaccess : opAccess = A_Unknown
  val mutable _oplen: int = 0
  val mutable _opaddr: Libasmir.address_t = 0L
  val mutable _opvalue: Int32.t = 0l
  val mutable _taintflag: Int64.t = 0L
  val mutable _records: taintRecord array = [||]
  (* These two fields defined for compatibility *)
  val mutable _origin: Int32.t array = [||]
  val mutable _offset: Int32.t array = [||]
  (* Interface methods *)
  method optype = _optype
  method opaccess = _opaccess
  method oplen = _oplen
  method opaddr = _opaddr
  method opvalue = _opvalue
  method taintflag = _taintflag
  method origin = _origin
  method offset = _offset
  (* Additional methods *)
  method records = _records
  method opusage = _opusage

  method private read_taint_byte_record ic =
    let source = IO.read_real_i32 ic in
    let origin = IO.read_real_i32 ic in
    let offset = IO.read_real_i32 ic in
    {
      source = source;
      origin = origin;
      offset = offset;
    }

  method private write_taint_byte_record oc tbr =
    IO.write_real_i32 oc tbr.source;
    IO.write_real_i32 oc tbr.origin;
    IO.write_real_i32 oc tbr.offset

  method private read_taint_record ic =
    let taint_propag = IO.read_ui16 ic in
    let num_records = IO.read_ui16 ic in
    let taint_bytes_arr =
	read_array (fun () -> self#read_taint_byte_record ic) num_records
    in
    let empty_taint_bytes_arr = Array.make (3 - num_records) empty_tbr in
    {
      taint_propag = taint_propag;
      num_records = num_records;
      taint_bytes = Array.append taint_bytes_arr empty_taint_bytes_arr;
    }

  method private write_taint_record oc tr =
    IO.write_ui16 oc tr.taint_propag;
    IO.write_ui16 oc tr.num_records;
    for i = 0 to (tr.num_records - 1) do
      self#write_taint_byte_record oc tr.taint_bytes.(i)
    done

  method private read_records ic oplen optaint =
    let records_arr = Array.make 4 empty_tr in
    for i = 0 to (oplen - 1) do
      if ((Int64.logand optaint (Int64.of_int (1 lsl i))) <> 0L) then (
	Array.set records_arr i (self#read_taint_record ic)
      )
    done;
    records_arr

  method private write_records oc oplen optaint =
    for i = 0 to (oplen - 1) do
      if ((Int64.logand optaint (Int64.of_int (1 lsl i))) <> 0L) then (
	self#write_taint_record oc _records.(i)
      )
    done;

  method private get_origin records =
    let reclist = Array.to_list records in
    let add_origin l tr = tr.taint_bytes.(0).origin :: l in
    let origin_list = List.fold_left add_origin [] reclist in
    let origin_list = List.rev origin_list in
    Array.of_list origin_list

  method private get_offset records =
    let reclist = Array.to_list records in
    let add_offset l tr = tr.taint_bytes.(0).offset :: l in
    let offset_list = List.fold_left add_offset [] reclist in
    let offset_list = List.rev offset_list in
    Array.of_list offset_list

  method serialize oc =
    let rawoptype =
      match _optype with
          TNone -> 0
        | TRegister -> 1
        | TMemLoc -> 2
        | TImmediate -> 3
        | TJump -> 4
        | TFloatRegister -> 5
        | TMemAddress ->6
    in
    let rawopusage =
      match _opusage with
        | UUnknown -> 0
        | UEsp -> 1
        | UCounter -> 2
        | UMemBase -> 3
        | UMemIndex -> 4
        | UMemSegment -> 5
        | UMemSegent0 -> 6
        | UMemSegent1 -> 7
    in
    let addr = Int64.to_int32 _opaddr in
      IO.write_i32 oc rawoptype;
      IO.write_i32 oc rawopusage;
      IO.write_i32 oc _oplen;
      IO.write_real_i32 oc addr;
      IO.write_real_i32 oc _opvalue;
      IO.write_i64 oc _taintflag;
      self#write_records oc _oplen _taintflag;

  method unserialize ic =
    let ot =
      match IO.read_i32 ic with
        | 0 -> TNone
        | 1 -> TRegister
        | 2 -> TMemLoc
        | 3 -> TImmediate
        | 4 -> TJump
        | 5 -> TFloatRegister
        | 6 -> TMemAddress
        | _ -> TNone
    in
    let ou =
      match IO.read_i32 ic with
        | 0 -> UUnknown
        | 1 -> UEsp
        | 2 -> UCounter
        | 3 -> UMemBase
        | 4 -> UMemIndex
        | 5 -> UMemSegment
        | 6 -> UMemSegent0
        | 7 -> UMemSegent1
        | _ -> UUnknown
    in
    let len = Int32.to_int (IO.read_real_i32 ic) in
    let ad = int64_of_uint32 (IO.read_real_i32 ic) in
    let vl = IO.read_real_i32 ic in
    let tn = IO.read_i64 ic in
    let records = self#read_records ic len tn in
    let og = self#get_origin records in
    let os = self#get_offset records in
      _optype <- ot;
      _opusage <- ou;
      _oplen <- len;
      _opaddr <- ad;
      _opvalue <- vl;
      _taintflag <- tn;
      _records <- records;
      _origin <- og;
      _offset <- os;
end

class instruction_v41 =
object (self)
  inherit instruction
  val mutable _addr: Libasmir.address_t = 0L
  val mutable _tid: Int32.t = 0l
  val mutable _inst_size: int = 0
  val mutable _num_operands: int = 0
  val mutable _tp: taintProp = TPUnknown
  val mutable _rawbytes: char array = [||]
  val mutable _operand: operand_v41 array = [||]
  val mutable _memregs: operand_v41 array array = [||]
  val mutable _esp: operand_v41 = new operand_v41
  val mutable _eflags: Int32.t = 0l
  val mutable _cc_op: Int32.t = 0l
  val mutable _df: Int32.t = 0l
  val mutable _hflags: Int32.t = 0l
  val mutable _ldt: Int32.t = 0l
  val mutable _gdt: Int32.t = 0l
  val mutable _tr: Int32.t = 0l
  val mutable _idt: Int32.t = 0l
  (* Auxiliary methods *)
  method private create_operand op_arr =
    let add_operand op = (op : operand_v41 :> operand) in
    Array.map add_operand op_arr
  method private create_memregs op_arr_arr =
    let add_memreg mr = self#create_operand mr in
    Array.map add_memreg op_arr_arr
  (* Interface methods *)
  method pid = 0
  method address = _addr
  method rawbytes = _rawbytes
  method operand = self#create_operand _operand
  method memregs = self#create_memregs _memregs
  method esp = (_esp : operand_v41 :> operand)
  method eflags = _eflags
  method cc_op = _cc_op
  method df = _df
  method hflags = _hflags
  method ldt = _ldt
  method gdt = _gdt
  method tr = _tr
  method idt = _idt
  method inst_size = _inst_size
  method num_operands = _num_operands
  method tp = _tp
  method thread_id = _tid
  (* Additional methods *)
  method operand_or = _operand
  method esp_or = _esp

  method serialize oc =
    let write_tp oc =
      let tp_int =
        match _tp with
          | TPNone -> 0
          | TPSrc -> 1
          | TPCjmp -> 2
          | TPMemReadIndex -> 3
          | TPMemWriteIndex -> 4
          | TPRepCounter -> 5
          | TPUnknown -> failwith "Cannot write TPUnknown"
      in
      IO.write_byte oc tp_int
    in

    let write_operands oc op_arr memreg_arr =
      for i = 0 to 2 do
        let op = Array.get op_arr i in
        if (op#optype <> TNone) then (
          op#serialize oc;
          if ((op#optype = TMemLoc) || (op#optype = TMemAddress)) then (
            for j = 0 to 2 do
              let memreg = Array.get (Array.get memreg_arr i) j in
              if (memreg#optype <> TNone) then memreg#serialize oc;
            done;
            let segent0 = Array.get op_arr 3 in
            let segent1 = Array.get op_arr 4 in
            if (segent0#optype <> TNone) then segent0#serialize oc;
            if (segent1#optype <> TNone) then segent1#serialize oc;
          )
        )
      done
    in
    let write_rawbytes oc =
      let raw_rb = Array.sub _rawbytes 0 _inst_size in
      write_array (fun () ch -> IO.write oc ch) raw_rb
    in
    let addr = Int64.to_int32 _addr in
      IO.write_real_i32 oc addr;
      IO.write_real_i32 oc _tid;
      IO.write_ui16 oc _inst_size;
      IO.write_byte oc _num_operands;
      write_tp oc;
      IO.write_real_i32 oc _eflags;
      IO.write_real_i32 oc _cc_op;
      IO.write_real_i32 oc _df;
      IO.write_real_i32 oc _hflags;
      IO.write_real_i32 oc _ldt;
      IO.write_real_i32 oc _gdt;
      IO.write_real_i32 oc _tr;
      IO.write_real_i32 oc _idt;
      _esp#serialize oc;
      let _ = write_operands oc _operand _memregs in
      write_rawbytes oc

  method unserialize ic =
    let read_tp ic =
      let tp_int = IO.read_byte ic in
      match tp_int with
        | 0 -> TPNone
        | 1 -> TPSrc
        | 2 -> TPCjmp
        | 3 -> TPMemReadIndex
        | 4 -> TPMemWriteIndex
        | 5 -> TPRepCounter
        | 6 -> TPNone (* Sysenter gets converted into TPNone *)
        | _ -> TPUnknown
    in
    let read_operand ic =
      let opr = new operand_v41 in
      let () = opr#unserialize ic in
        opr
    in
    let read_operands ic num_op =
      let empty_operand = new operand_v41 in
      let op_arr = Array.make 5 empty_operand in
      let memreg_arr = Array.make_matrix 3 3 empty_operand in
      if (num_op > 0) then (
        let tmp_list =
          List.rev (read_list [] (fun () -> read_operand ic) num_op) in
        let process_operand i op =
          match op#opusage with
            | UMemBase ->
                Array.set (memreg_arr.(i-1)) 1 op; i
            | UMemIndex ->
                Array.set (memreg_arr.(i-1)) 2 op; i
            | UMemSegment ->
                Array.set (memreg_arr.(i-1)) 0 op; i
            | UMemSegent0 ->
                Array.set op_arr 3 op; i
            | UMemSegent1 ->
                Array.set op_arr 4 op; i
            | _ ->
                Array.set op_arr i op; i+1
        in
        let _ = List.fold_left process_operand 0 tmp_list in
        (op_arr,memreg_arr)
      )
      else (op_arr,memreg_arr)
    in
    let read_rawbytes ic is =
      let raw_rb = read_array (fun () -> IO.read ic) is in
      let empty_arr = Array.make (15 - is) (Char.chr 0) in
      Array.append raw_rb empty_arr
    in
    let ad = int64_of_uint32 (IO.read_real_i32 ic) in
    let ti = IO.read_real_i32 ic in
    let is = IO.read_ui16 ic in
    let no = IO.read_byte ic in
    let tp = read_tp ic in
    let ef = IO.read_real_i32 ic in
    let co = IO.read_real_i32 ic in
    let adf = IO.read_real_i32 ic in
    let hf = IO.read_real_i32 ic in
    let aldt = IO.read_real_i32 ic in
    let agdt = IO.read_real_i32 ic in
    let atr = IO.read_real_i32 ic in
    let aidt = IO.read_real_i32 ic in
    let sp = read_operand ic in
    let (op,mr) = read_operands ic no in
    let rb = read_rawbytes ic is in
      _addr <- ad;
      _tid <- ti;
      _inst_size <- is;
      _num_operands <- no;
      _tp <- tp;
      _eflags <- ef;
      _cc_op <- co;
      _df <- adf;
      _hflags <- hf;
      _ldt <- aldt;
      _gdt <- agdt;
      _tr <- atr;
      _idt <- aidt;
      _esp <- sp;
      _operand <- op;
      _memregs <- mr;
      _rawbytes <- rb;
end


(* =========== BEGIN: Trace version 40  ======================= *)
class operand_v40 =
object (self)
  inherit operand
  val mutable _optype: opType = TNone
  val mutable _opusage: opUsage = UUnknown
  val _opaccess : opAccess = A_Unknown
  val mutable _oplen: int = 0
  val mutable _opaddr: Libasmir.address_t = 0L
  val mutable _opvalue: Int32.t = 0l
  val mutable _taintflag: Int64.t = 0L
  val mutable _records: taintRecord array = [||]
  (* These two fields defined for compatibility *)
  val mutable _origin: Int32.t array = [||]
  val mutable _offset: Int32.t array = [||]
  (* Interface methods *)
  method optype = _optype
  method opaccess = _opaccess
  method oplen = _oplen
  method opaddr = _opaddr
  method opvalue = _opvalue
  method taintflag = _taintflag
  method origin = _origin
  method offset = _offset
  (* Additional methods *)
  method records = _records
  method opusage = _opusage

  method private read_taint_byte_record ic =
    let source = IO.read_real_i32 ic in
    let origin = IO.read_real_i32 ic in
    let offset = IO.read_real_i32 ic in
    {
      source = source;
      origin = origin;
      offset = offset;
    }

  method private write_taint_byte_record oc () tbr =
    IO.write_real_i32 oc tbr.source;
    IO.write_real_i32 oc tbr.origin;
    IO.write_real_i32 oc tbr.offset

  method private read_taint_record ic =
    let taint_propag = IO.read_ui16 ic in
    let num_records = IO.read_ui16 ic in
    {
      taint_propag = taint_propag;
      num_records = num_records;
      taint_bytes = read_array (fun () -> self#read_taint_byte_record ic) 3;
    }

  method private write_taint_record oc () tr =
    IO.write_ui16 oc tr.taint_propag;
    IO.write_ui16 oc tr.num_records;
    write_array (self#write_taint_byte_record oc) tr.taint_bytes

  method private get_origin records =
    let reclist = Array.to_list records in
    let add_origin l tr = tr.taint_bytes.(0).origin :: l in
    let origin_list = List.fold_left add_origin [] reclist in
    let origin_list = List.rev origin_list in
    Array.of_list origin_list

  method private get_offset records =
    let reclist = Array.to_list records in
    let add_offset l tr = tr.taint_bytes.(0).offset :: l in
    let offset_list = List.fold_left add_offset [] reclist in
    let offset_list = List.rev offset_list in
    Array.of_list offset_list

  method serialize oc =
    let rawoptype =
      match _optype with
	  TNone -> 0
	| TRegister -> 1
	| TMemLoc -> 2
	| TImmediate -> 3
	| TJump -> 4
	| TFloatRegister -> 5
        | TMemAddress ->6
    in
    let rawopusage =
      match _opusage with
        | UUnknown -> 0
        | UEsp -> 1
        | UCounter -> 2
        | UMemBase -> 3
        | UMemIndex -> 4
        | UMemSegment -> 5
        | UMemSegent0 -> 6
        | UMemSegent1 -> 7
    in
    let addr = Int64.to_int32 _opaddr in
      IO.write_i32 oc rawoptype;
      IO.write_i32 oc rawopusage;
      IO.write_i32 oc _oplen;
      IO.write_real_i32 oc addr;
      IO.write_real_i32 oc _opvalue;
      IO.write_i64 oc _taintflag;
      write_array (self#write_taint_record oc) _records

  method unserialize ic =
    let ot =
      match IO.read_i32 ic with
	| 0 -> TNone
	| 1 -> TRegister
	| 2 -> TMemLoc
	| 3 -> TImmediate
	| 4 -> TJump
	| 5 -> TFloatRegister
        | 6 -> TMemAddress
	| _ -> TNone
    in
    let ou =
      match IO.read_i32 ic with
        | 0 -> UUnknown
        | 1 -> UEsp
        | 2 -> UCounter
        | 3 -> UMemBase
        | 4 -> UMemIndex
        | 5 -> UMemSegment
        | 6 -> UMemSegent0
        | 7 -> UMemSegent1
        | _ -> UUnknown
    in
    let len = Int32.to_int (IO.read_real_i32 ic) in
    let ad = int64_of_uint32 (IO.read_real_i32 ic) in
    let vl = IO.read_real_i32 ic in
    let tn = IO.read_i64 ic in
    let records = read_array (fun () -> self#read_taint_record ic) 4 in
    let og = self#get_origin records in
    let os = self#get_offset records in
      _optype <- ot;
      _opusage <- ou;
      _oplen <- len;
      _opaddr <- ad;
      _opvalue <- vl;
      _taintflag <- tn;
      _records <- records;
      _origin <- og;
      _offset <- os;
end

class instruction_v40 =
object (self)
  inherit instruction
  val mutable _addr: Libasmir.address_t = 0L
  val mutable _tid: Int32.t = 0l
  val mutable _inst_size: int = 0
  val mutable _num_operands: int = 0
  val mutable _tp: taintProp = TPUnknown
  val mutable _rawbytes: char array = [||]
  val mutable _operand: operand_v40 array = [||]
  val mutable _memregs: operand_v40 array array = [||]
  val mutable _esp: operand_v40 = new operand_v40
  val mutable _eflags: Int32.t = 0l
  val mutable _cc_op: Int32.t = 0l
  val mutable _df: Int32.t = 0l
  val mutable _hflags: Int32.t = 0l
  val mutable _ldt: Int32.t = 0l
  val mutable _gdt: Int32.t = 0l
  val mutable _tr: Int32.t = 0l
  val mutable _idt: Int32.t = 0l
  (* Auxiliary methods *)
  method private create_operand op_arr =
    let add_operand op = (op : operand_v40 :> operand) in
    Array.map add_operand op_arr
  method private create_memregs op_arr_arr =
    let add_memreg mr = self#create_operand mr in
    Array.map add_memreg op_arr_arr
  (* Interface methods *)
  method pid = 0
  method address = _addr
  method rawbytes = _rawbytes
  method operand = self#create_operand _operand
  method memregs = self#create_memregs _memregs
  method esp = (_esp : operand_v40 :> operand)
  method eflags = _eflags
  method cc_op = _cc_op
  method df = _df
  method hflags = _hflags
  method ldt = _ldt
  method gdt = _gdt
  method tr = _tr
  method idt = _idt
  method inst_size = _inst_size
  method num_operands = _num_operands
  method tp = _tp
  method thread_id = _tid
  (* Additional methods *)
  method operand_or = _operand
  method esp_or = _esp

  method serialize oc =
    let write_tp oc =
      let tp_int =
	match _tp with
	  | TPNone -> 0
	  | TPSrc -> 1
	  | TPCjmp -> 2
	  | TPMemReadIndex -> 3
	  | TPMemWriteIndex -> 4
	  | TPRepCounter -> 5
	  | TPUnknown -> failwith "Cannot write TPUnknown"
      in
      IO.write_byte oc tp_int
    in

    let write_operands oc op_arr memreg_arr =
      for i = 0 to 2 do
	let op = Array.get op_arr i in
	if (op#optype <> TNone) then (
	  op#serialize oc;
	  if ((op#optype = TMemLoc) || (op#optype = TMemAddress)) then (
	    for j = 0 to 2 do
	      let memreg = Array.get (Array.get memreg_arr i) j in
	      if (memreg#optype <> TNone) then memreg#serialize oc;
	    done;
	    let segent0 = Array.get op_arr 3 in
	    let segent1 = Array.get op_arr 4 in
	    if (segent0#optype <> TNone) then segent0#serialize oc;
	    if (segent1#optype <> TNone) then segent1#serialize oc;
	  )
	)
      done
    in
    let write_rawbytes oc =
      let raw_rb = Array.sub _rawbytes 0 _inst_size in
      write_array (fun () ch -> IO.write oc ch) raw_rb
    in
    let addr = Int64.to_int32 _addr in
      IO.write_real_i32 oc addr;
      IO.write_real_i32 oc _tid;
      IO.write_ui16 oc _inst_size;
      IO.write_byte oc _num_operands;
      write_tp oc;
      IO.write_real_i32 oc _eflags;
      IO.write_real_i32 oc _cc_op;
      IO.write_real_i32 oc _df;
      IO.write_real_i32 oc _hflags;
      IO.write_real_i32 oc _ldt;
      IO.write_real_i32 oc _gdt;
      IO.write_real_i32 oc _tr;
      IO.write_real_i32 oc _idt;
      _esp#serialize oc;
      let _ = write_operands oc _operand _memregs in
      write_rawbytes oc

  method unserialize ic =
    let read_tp ic =
      let tp_int = IO.read_byte ic in
      match tp_int with
	| 0 -> TPNone
	| 1 -> TPSrc
	| 2 -> TPCjmp
	| 3 -> TPMemReadIndex
	| 4 -> TPMemWriteIndex
	| 5 -> TPRepCounter
	| 6 -> TPNone (* Sysenter gets converted into TPNone *)
	| _ -> TPUnknown
    in
    let read_operand ic =
      let opr = new operand_v40 in
      let () = opr#unserialize ic in
	opr
    in
    let read_operands ic num_op =
      let empty_operand = new operand_v40 in
      let op_arr = Array.make 5 empty_operand in
      let memreg_arr = Array.make_matrix 3 3 empty_operand in
      if (num_op > 0) then (
	let tmp_list =
	  List.rev (read_list [] (fun () -> read_operand ic) num_op) in
	let process_operand i op =
	  match op#opusage with
	    | UMemBase ->
		Array.set (memreg_arr.(i-1)) 1 op; i
	    | UMemIndex ->
		Array.set (memreg_arr.(i-1)) 2 op; i
	    | UMemSegment ->
		Array.set (memreg_arr.(i-1)) 0 op; i
	    | UMemSegent0 ->
		Array.set op_arr 3 op; i
	    | UMemSegent1 ->
		Array.set op_arr 4 op; i
	    | _ ->
		Array.set op_arr i op; i+1
	in
	let _ = List.fold_left process_operand 0 tmp_list in
	(op_arr,memreg_arr)
      )
      else (op_arr,memreg_arr)
    in
    let read_rawbytes ic is =
      let raw_rb = read_array (fun () -> IO.read ic) is in
      let empty_arr = Array.make (15 - is) (Char.chr 0) in
      Array.append raw_rb empty_arr
    in
    let ad = int64_of_uint32 (IO.read_real_i32 ic) in
    let ti = IO.read_real_i32 ic in
    let is = IO.read_ui16 ic in
    let no = IO.read_byte ic in
    let tp = read_tp ic in
    let ef = IO.read_real_i32 ic in
    let co = IO.read_real_i32 ic in
    let adf = IO.read_real_i32 ic in
    let hf = IO.read_real_i32 ic in
    let aldt = IO.read_real_i32 ic in
    let agdt = IO.read_real_i32 ic in
    let atr = IO.read_real_i32 ic in
    let aidt = IO.read_real_i32 ic in
    let sp = read_operand ic in
    let (op,mr) = read_operands ic no in
    let rb = read_rawbytes ic is in
      _addr <- ad;
      _tid <- ti;
      _inst_size <- is;
      _num_operands <- no;
      _tp <- tp;
      _eflags <- ef;
      _cc_op <- co;
      _df <- adf;
      _hflags <- hf;
      _ldt <- aldt;
      _gdt <- agdt;
      _tr <- atr;
      _idt <- aidt;
      _esp <- sp;
      _operand <- op;
      _memregs <- mr;
      _rawbytes <- rb;
end

(* =========== BEGIN: Trace version 20 ============ *)
class operand_v20 =
object (self)
  inherit operand
  val mutable _optype: opType = TNone
  val _opaccess : opAccess = A_Unknown
  val mutable _oplen: int = 0
  val mutable _opaddr: Libasmir.address_t = 0L
  val mutable _opvalue: Int32.t = 0l
  val mutable _taintflag: Int64.t = 0L
  val mutable _records: taintRecord array = [||]
  (* These two fields defined for compatibility *)
  val mutable _origin: Int32.t array = [||]
  val mutable _offset: Int32.t array = [||]
  (* Interface methods *)
  method optype = _optype
  method opaccess = _opaccess
  method oplen = _oplen
  method opaddr = _opaddr
  method opvalue = _opvalue
  method taintflag = _taintflag
  method origin = _origin
  method offset = _offset
  (* Additional methods *)
  method records = _records

  method private read_taint_byte_record ic =
    let source = IO.read_real_i32 ic in
    let origin = IO.read_real_i32 ic in
    let offset = IO.read_real_i32 ic in
    {
      source = source;
      origin = origin;
      offset = offset;
    }

  method private write_taint_byte_record oc () tbr =
    IO.write_real_i32 oc tbr.source;
    IO.write_real_i32 oc tbr.origin;
    IO.write_real_i32 oc tbr.offset

  method private read_taint_record ic =
    let taint_propag = IO.read_ui16 ic in
    let num_records = IO.read_ui16 ic in
    {
      taint_propag = taint_propag;
      num_records = num_records;
      taint_bytes = read_array (fun () -> self#read_taint_byte_record ic) 3;
    }

  method private write_taint_record oc () tr =
    IO.write_ui16 oc tr.taint_propag;
    IO.write_ui16 oc tr.num_records;
    write_array (self#write_taint_byte_record oc) tr.taint_bytes

  method private get_origin records =
    let reclist = Array.to_list records in
    let add_origin l tr = tr.taint_bytes.(0).origin :: l in
    let origin_list = List.fold_left add_origin [] reclist in
    let origin_list = List.rev origin_list in
    Array.of_list origin_list

  method private get_offset records =
    let reclist = Array.to_list records in
    let add_offset l tr = tr.taint_bytes.(0).offset :: l in
    let offset_list = List.fold_left add_offset [] reclist in
    let offset_list = List.rev offset_list in
    Array.of_list offset_list

  method serialize oc =
    let rawoptype =
      match _optype with
	  TNone -> 0
	| TRegister -> 1
	| TMemLoc -> 2
	| TImmediate -> 3
	| TJump -> 4
	| TFloatRegister -> 5
        | TMemAddress ->6
    in
    let addr = Int64.to_int32 _opaddr in
      IO.write_i32 oc rawoptype;
      IO.write_i32 oc _oplen;
      IO.write_real_i32 oc addr;
      IO.write_real_i32 oc _opvalue;
      IO.write_i64 oc _taintflag;
      write_array (self#write_taint_record oc) _records

  method unserialize ic =
    let ot =
      match IO.read_i32 ic with
	| 0 -> TNone
	| 1 -> TRegister
	| 2 -> TMemLoc
	| 3 -> TImmediate
	| 4 -> TJump
	| 5 -> TFloatRegister
        | 6 -> TMemAddress
	| _ -> TNone
    in
    let len = Int32.to_int (IO.read_real_i32 ic) in
    let ad = int64_of_uint32 (IO.read_real_i32 ic) in
    let vl = IO.read_real_i32 ic in
    let tn = IO.read_i64 ic in
    let records = read_array (fun () -> self#read_taint_record ic) 4 in
    let og = self#get_origin records in
    let os = self#get_offset records in
      _optype <- ot;
      _oplen <- len;
      _opaddr <- ad;
      _opvalue <- vl;
      _taintflag <- tn;
      _records <- records;
      _origin <- og;
      _offset <- os;
end

class instruction_v20 =
object (self)
  inherit instruction
  val mutable _addr: Libasmir.address_t = 0L
  val mutable _opcode: int array = [||]
  val mutable _prefixes: Int32.t = 0l
  val mutable _modrm: int = 0
  val mutable _rawbytes: char array = [||]
  val mutable _insn : char array = [||]
  val mutable _operand: operand_v20 array = [||]
  val mutable _memregs: operand_v20 array array = [||]
  val mutable _esp: operand_v20 = new operand_v20
  val mutable _eflags: Int32.t = 0l
  val mutable _cc_op: Int32.t = 0l
  val mutable _df: Int32.t = 0l
  val mutable _hflags: Int32.t = 0l
  val mutable _ldt: Int32.t = 0l
  val mutable _gdt: Int32.t = 0l
  val mutable _tr: Int32.t = 0l
  val mutable _idt: Int32.t = 0l
  (* Auxiliary methods *)
  method private create_operand op_arr =
    let add_operand op = (op : operand_v20 :> operand) in
    Array.map add_operand op_arr
  method private create_memregs op_arr_arr =
    let add_memreg mr = self#create_operand mr in
    Array.map add_memreg op_arr_arr
  (* Interface methods *)
  method pid = 0
  method address = _addr
  method rawbytes = _rawbytes
  method operand = self#create_operand _operand
  method memregs = self#create_memregs _memregs
  method esp = (_esp : operand_v20 :> operand)
  method eflags = _eflags
  method cc_op = _cc_op
  method df = _df
  method hflags = _hflags
  method ldt = _ldt
  method gdt = _gdt
  method tr = _tr
  method idt = _idt
  method inst_size = -1
  method num_operands = -1
  method tp = TPUnknown
  method thread_id = 0l
  (* Additional methods *)
  method opcode = _opcode
  method prefixes = _prefixes
  method modrm = _modrm
  method operand_or = _operand
  method esp_or = _esp

  method private read_modrm ic =
    let mo = IO.read_byte ic in
    let insn = read_array (fun () -> IO.read ic) 91
    in
      _insn <- insn; mo

  method private write_address oc address =
    IO.write_real_i32 oc address;
    write_array (fun () i -> IO.write oc (Char.chr i)) _opcode;
    IO.write oc '\000';
    IO.write_real_i32 oc _prefixes;
    IO.write oc (Char.chr _modrm);
    write_array (fun () i -> IO.write oc i) _insn

  method serialize oc =
    let addr = Int64.to_int32 _addr in
      self#write_address oc addr;
      write_array (fun () ch -> IO.write oc ch) _rawbytes;
      write_array (fun () ch -> IO.write oc ch) [|'\000'|];
      write_array (fun () opr -> opr#serialize oc) _operand;
      write_array (fun () mem -> write_array
	(fun () opr -> opr#serialize oc) mem) _memregs;
      _esp#serialize oc;
      IO.write_real_i32 oc _eflags;
      IO.write_real_i32 oc _cc_op;
      IO.write_real_i32 oc _df;
      IO.write_real_i32 oc _hflags;
      IO.write_real_i32 oc _ldt;
      IO.write_real_i32 oc _gdt;
      IO.write_real_i32 oc _tr;
      IO.write_real_i32 oc _idt

  method unserialize ic =
    let read_operand ic =
      let opr = new operand_v20 in
      let () = opr#unserialize ic in
	opr
    in
    let ad = int64_of_uint32 (IO.read_real_i32 ic) in
    let oc = read_array (fun () -> IO.read_byte ic) 3 in
    let _ = IO.read_byte ic in (* padding *)
    let pr = IO.read_real_i32 ic in
    let mo = self#read_modrm ic in
    let rb = read_array (fun () -> IO.read ic) 15 in
    let _ = read_array (fun () -> IO.read ic) 1 in (* padding *)
    let op = read_array (fun () -> read_operand ic) 5 in
    let mr =
      read_array
	(fun () -> read_array (fun () -> read_operand ic) 3)
	3
    in
    let sp = read_operand ic in
    let ef = IO.read_real_i32 ic in
    let co = IO.read_real_i32 ic in
    let adf = IO.read_real_i32 ic in
    let hf = IO.read_real_i32 ic in
    let aldt = IO.read_real_i32 ic in
    let agdt = IO.read_real_i32 ic in
    let atr = IO.read_real_i32 ic in
    let aidt = IO.read_real_i32 ic in
      _addr <- ad;
      _opcode <- oc;
      _prefixes <- pr;
      _modrm <- mo;
      _rawbytes <- rb;
      _operand <- op;
      _memregs <- mr;
      _esp <- sp;
      _eflags <- ef;
      _cc_op <- co;
      _df <- adf;
      _hflags <- hf;
      _ldt <- aldt;
      _gdt <- agdt;
      _tr <- atr;
      _idt <- aidt;
end

(* =========== BEGIN: Trace version 30 ============ *)
class operand_v30 =
object
  inherit operand
  val mutable _optype: opType = TNone
  val _opaccess : opAccess = A_Unknown
  val mutable _opaddr: Libasmir.address_t = 0L
  val mutable _opvalue: Int32.t = 0l
  val mutable _taintflag: Int64.t = 0L
  val mutable _origin: Int32.t array = [||]
  val mutable _offset: Int32.t array = [||]
  val mutable _srcid: Int32.t array = [||]
  val mutable _newid: char array = [||]

  method optype = _optype
  method opaccess = _opaccess
  method opaddr = _opaddr
  method oplen =
    match _optype with
      | TRegister -> reglen_of_addr _opaddr
      | TMemLoc -> 4
      | _ -> 4
  method opvalue = _opvalue
  method taintflag = _taintflag
  method origin = _origin
  method offset = _offset
  method srcid = _srcid
  method newid = _newid

  method serialize oc =
    let rawoptype =
      match _optype with
	  TNone -> 0
	| TRegister -> 1
	| TMemLoc -> 2
	| TImmediate -> 3
	| TJump -> 4
	| TFloatRegister -> 5
        | TMemAddress -> 6
    in
    let addr = Int64.to_int32 _opaddr in
      IO.write_i32 oc rawoptype;
      IO.write_real_i32 oc addr;
      IO.write_real_i32 oc _opvalue;
      IO.write_i64 oc _taintflag;
      write_array (fun () i -> IO.write_real_i32 oc i) _origin;
      write_array (fun () i -> IO.write_real_i32 oc i) _offset;
      write_array (fun () i -> IO.write_real_i32 oc i) _srcid;
      write_array (fun () i -> IO.write oc i) _newid

  method unserialize ic =
    let ot =
      match IO.read_i32 ic with
	| 0 -> TNone
	| 1 -> TRegister
	| 2 -> TMemLoc
	| 3 -> TImmediate
	| 4 -> TJump
	| 5 -> TFloatRegister
        | 6 -> TMemAddress
	| _ -> TNone
    in
    let ad = int64_of_uint32 (IO.read_real_i32 ic) in
    let vl = IO.read_real_i32 ic in
    let tn = IO.read_i64 ic in
    let og = read_array (fun () -> IO.read_real_i32 ic) 4 in
    let os = read_array (fun () -> IO.read_real_i32 ic) 4 in
    let src = read_array (fun () -> IO.read_real_i32 ic) 4 in
    let nid = read_array (fun () -> IO.read ic) 4 in
      _optype <- ot;
      _opaddr <- ad;
      _opvalue <- vl;
      _taintflag <- tn;
      _origin <- og;
      _offset <- os;
      _srcid <- src;
      _newid <- nid

end

class instruction_v30 =
object (self)
  inherit instruction
  val mutable _addr: Libasmir.address_t = 0L
  val mutable _rawbytes: char array = [||]
  val mutable _operand: operand_v30 array = [||]
  val mutable _memregs: operand_v30 array array = [||]
  val mutable _esp: operand_v30 = new operand_v30
  val mutable _eflags: Int32.t = 0l
  val mutable _cc_op: Int32.t = 0l
  val mutable _df: Int32.t = 0l
  val mutable _hflags: Int32.t = 0l
  val mutable _ldt: Int32.t = 0l
  val mutable _gdt: Int32.t = 0l
  val mutable _tr: Int32.t = 0l
  val mutable _idt: Int32.t = 0l

  method private create_operand op_arr =
    let add_operand op = (op : operand_v30 :> operand) in
    Array.map add_operand op_arr

  method private create_memregs op_arr_arr =
    let add_memreg mr = self#create_operand mr in
    Array.map add_memreg op_arr_arr

  method operand_v30 = _operand

  method size = 1132
  method pid = 0
  method address = _addr
  method rawbytes = _rawbytes
  method operand = self#create_operand _operand
  method memregs = self#create_memregs _memregs
  method esp = (_esp : operand_v30 :> operand)
  method eflags = _eflags
  method cc_op = _cc_op
  method df = _df
  method hflags = _hflags
  method ldt = _ldt
  method gdt = _gdt
  method tr = _tr
  method idt = _idt
  method inst_size = -1
  method num_operands = -1
  method tp = TPUnknown
  method thread_id = 0l

  method private read_address ic =
    int64_of_uint32 (IO.read_real_i32 ic)

  method private write_address oc address =
    IO.write_real_i32 oc address;

  method serialize oc =
    let addr = Int64.to_int32 _addr in
      self#write_address oc addr;
      write_array (fun () ch -> IO.write oc ch) _rawbytes;
      write_array (fun () ch -> IO.write oc ch) [|'\000'|];
      write_array (fun () opr -> opr#serialize oc) _operand;
      write_array (fun () mem -> write_array (fun () opr -> opr#serialize oc) mem) _memregs;
      _esp#serialize oc;
      IO.write_real_i32 oc _eflags;
      IO.write_real_i32 oc _cc_op;
      IO.write_real_i32 oc _df;
      IO.write_real_i32 oc _hflags;
      IO.write_real_i32 oc _ldt;
      IO.write_real_i32 oc _gdt;
      IO.write_real_i32 oc _tr;
      IO.write_real_i32 oc _idt

  method unserialize ic =
    let read_operand ic =
      let opr = new operand_v30 in
      let () = opr#unserialize ic in
	opr
    in
    let ad = self#read_address ic in
    let rb = read_array (fun () -> IO.read ic) 15 in
    let _ = read_array (fun () -> IO.read ic) 1 in (* padding *)
    let op = read_array (fun () -> read_operand ic) 5 in
    let mr =
      read_array
	(fun () -> read_array (fun () -> read_operand ic) 3)
	3
    in
    let sp = read_operand ic in
    let ef = IO.read_real_i32 ic in
    let co = IO.read_real_i32 ic in
    let adf = IO.read_real_i32 ic in
    let hf = IO.read_real_i32 ic in
    let aldt = IO.read_real_i32 ic in
    let agdt = IO.read_real_i32 ic in
    let atr = IO.read_real_i32 ic in
    let aidt = IO.read_real_i32 ic in
      _addr <- ad;
      _rawbytes <- rb;
      _operand <- op;
      _memregs <- mr;
      _esp <- sp;
      _eflags <- ef;
      _cc_op <- co;
      _df <- adf;
      _hflags <- hf;
      _ldt <- aldt;
      _gdt <- agdt;
      _tr <- atr;
      _idt <- aidt
end

(* =========== END: Trace version 30 ============ *)


(* =========== BEGIN: Trace version 10 and before ============ *)
class operand_v10 =
object
  inherit operand
  val mutable _optype: opType = TNone
  val _opaccess : opAccess = A_Unknown
  val mutable _opaddr: Libasmir.address_t = 0L
  val mutable _opvalue: Int32.t = 0l
  val mutable _taintflag: Int64.t = 0L
  val mutable _origin: Int32.t array = [||]
  val mutable _offset: Int32.t array = [||]
  method optype = _optype
  method opaccess = _opaccess
  method oplen =
    match _optype with
      | TRegister -> reglen_of_addr _opaddr
      | TMemLoc -> 4
      | _ -> 4
  method opaddr = _opaddr
  method opvalue = _opvalue
  method taintflag = _taintflag
  method origin = _origin
  method offset = _offset

  method serialize oc =
    let rawoptype =
      match _optype with
	  TNone -> 0
	| TRegister -> 1
	| TMemLoc -> 2
	| TImmediate -> 3
	| TJump -> 4
	| TFloatRegister -> 5
        | TMemAddress -> 6
    in
    let addr = Int64.to_int32 _opaddr in
      IO.write_i32 oc rawoptype;
      IO.write_real_i32 oc addr;
      IO.write_real_i32 oc _opvalue;
      IO.write_i64 oc _taintflag;
      write_array (fun () i -> IO.write_real_i32 oc i) _origin;
      write_array (fun () i -> IO.write_real_i32 oc i) _offset

  method unserialize ic =
    let ot =
      match IO.read_i32 ic with
	| 0 -> TNone
	| 1 -> TRegister
	| 2 -> TMemLoc
	| 3 -> TImmediate
	| 4 -> TJump
	| 5 -> TFloatRegister
        | 6 -> TMemAddress
	| _ -> TNone
    in
    let ad = int64_of_uint32 (IO.read_real_i32 ic) in
    let vl = IO.read_real_i32 ic in
    let tn = IO.read_i64 ic in
    let og = read_array (fun () -> IO.read_real_i32 ic) 4 in
    let os = read_array (fun () -> IO.read_real_i32 ic) 4 in
      _optype <- ot;
      _opaddr <- ad;
      _opvalue <- vl;
      _taintflag <- tn;
      _origin <- og;
      _offset <- os
end

class instruction_v10 =
object (self)
  inherit instruction
  val mutable _addr: Libasmir.address_t = 0L
  val mutable _rawbytes: char array = [||]
  val mutable _insn : char array = [||]
  val mutable _operand: operand_v10 array = [||]
  val mutable _memregs: operand_v10 array array = [||]
  val mutable _esp: operand_v10 = new operand_v10
  val mutable _eflags: Int32.t = 0l
  val mutable _cc_op: Int32.t = 0l
  val mutable _df: Int32.t = 0l
  val mutable _hflags: Int32.t = 0l
  val mutable _ldt: Int32.t = 0l
  val mutable _gdt: Int32.t = 0l
  val mutable _tr: Int32.t = 0l
  val mutable _idt: Int32.t = 0l
  (* Auxiliary methods *)
  method private create_operand op_arr =
    let add_operand op = (op : operand_v10 :> operand) in
    Array.map add_operand op_arr
  method private create_memregs op_arr_arr =
    let add_memreg mr = self#create_operand mr in
    Array.map add_memreg op_arr_arr
  (* Interface methods *)
  method pid = 0
  method address = _addr
  method rawbytes = _rawbytes
  method operand = self#create_operand _operand
  method memregs = self#create_memregs _memregs
  method esp = (_esp : operand_v10 :> operand)
  method eflags = _eflags
  method cc_op = _cc_op
  method df = _df
  method hflags = _hflags
  method ldt = _ldt
  method gdt = _gdt
  method tr = _tr
  method idt = _idt
  method inst_size = -1
  method num_operands = -1
  method tp = TPUnknown
  method thread_id = 0l

  method private read_address ic =
    let address = int64_of_uint32 (IO.read_real_i32 ic) in
    let insn = read_array (fun () -> IO.read ic) 100
    in
      _insn <- insn; address

  method private write_address oc address =
    IO.write_real_i32 oc address;
    write_array (fun () i -> IO.write oc i) _insn

  method serialize oc =
    let addr = Int64.to_int32 _addr in
      self#write_address oc addr;
      write_array (fun () ch -> IO.write oc ch) _rawbytes;
      write_array (fun () ch -> IO.write oc ch) [|'\000';'\000'|];
      write_array (fun () opr -> opr#serialize oc) _operand;
      write_array (fun () mem -> write_array (fun () opr -> opr#serialize oc) mem) _memregs;
      _esp#serialize oc;
      IO.write_real_i32 oc _eflags;
      IO.write_real_i32 oc _cc_op;
      IO.write_real_i32 oc _df;
      IO.write_real_i32 oc _hflags;
      IO.write_real_i32 oc _ldt;
      IO.write_real_i32 oc _gdt;
      IO.write_real_i32 oc _tr;
      IO.write_real_i32 oc _idt

  method unserialize ic =
    let read_operand ic =
      let opr = new operand_v10 in
      let () = opr#unserialize ic in
	opr
    in
    let ad = self#read_address ic in
    let rb = read_array (fun () -> IO.read ic) 10 in
    let _ = read_array (fun () -> IO.read ic) 2 in (* padding *)
    let op = read_array (fun () -> read_operand ic) 5 in
    let mr =
      read_array
	(fun () -> read_array (fun () -> read_operand ic) 3)
	3
    in
    let sp = read_operand ic in
    let ef = IO.read_real_i32 ic in
    let co = IO.read_real_i32 ic in
    let adf = IO.read_real_i32 ic in
    let hf = IO.read_real_i32 ic in
    let aldt = IO.read_real_i32 ic in
    let agdt = IO.read_real_i32 ic in
    let atr = IO.read_real_i32 ic in
    let aidt = IO.read_real_i32 ic in
      _addr <- ad;
      _rawbytes <- rb;
      _operand <- op;
      _memregs <- mr;
      _esp <- sp;
      _eflags <- ef;
      _cc_op <- co;
      _df <- adf;
      _hflags <- hf;
      _ldt <- aldt;
      _gdt <- agdt;
      _tr <- atr;
      _idt <- aidt
end

(* =========== END: Trace version 10 and before ============ *)

exception No_trace_header

(***  read trace header
    @param tchannel Trace input channel
    @return Version number of trace format and number of process in trace
    @raise No_trace_header This is an old trace, without a header
*)
let read_header tc =
  let cMAGIC_NUMBER = Int32.of_string "0xFFFFFFFF" in
  let magicnum = IO.read_real_i32 tc in
    if (magicnum = cMAGIC_NUMBER) then (
	let versionnum = IO.read_i32 tc in
	let nprocs = IO.read_i32 tc in
	let gdt = 
	  if (versionnum >= 50) then (int64_of_uint32 (IO.read_real_i32 tc))
	  else 0L
	in
	let idt = 
	  if (versionnum >= 50) then (int64_of_uint32 (IO.read_real_i32 tc))
	  else 0L
	in
	{
	  magicnumber = magicnum;
	  version = versionnum;
	  n_procs = nprocs;
	  gdt_base = gdt;
	  idt_base = idt;
	}
    )
    else
      raise No_trace_header

class mod_info =
object
  val mutable _name : char array = [||]
  val mutable _base : Int64.t = 0L
  val mutable _size : Int64.t = 0L
  method name = string_of_array _name
  method base = _base
  method size = _size
  method serialize (tc : unit IO.output) =
    write_array (fun () ch -> IO.write tc ch) _name;
    IO.write_real_i32 tc (Int64.to_int32 _base);
    IO.write_real_i32 tc (Int64.to_int32 _size)

  method unserialize (tc : IO.input) =
    let name = read_array (fun () -> IO.read tc) 32 in
    let base = int64_of_uint32 (IO.read_real_i32 tc) in
    let size = int64_of_uint32 (IO.read_real_i32 tc) in
      _name <- name;
      _base <- base;
      _size <- size
end

let read_module tc =
  let minfo = new mod_info in
    minfo#unserialize tc; minfo

class proc_info version =
object
  val mutable _name : char array = [||]
  val mutable _pid : int = 0
  val mutable _modules : mod_info list = []
  val mutable _ldt_base : Libasmir.address_t = 0L
  val mutable _version : int = version
  method name = string_of_array _name
  method pid = _pid
  method modules = _modules
  method ldt_base = _ldt_base
  method serialize (tc : unit IO.output) =
    let nmods = List.length _modules in
      write_array (fun () ch -> IO.write tc ch) _name;
      IO.write_i32 tc _pid;
      IO.write_i32 tc nmods;
      if (_version >= 50) then IO.write_real_i32 tc (Int64.to_int32 _ldt_base);
      List.iter (fun minfo -> minfo#serialize tc) _modules

  method unserialize (tc : IO.input) =
    let name = read_array (fun () -> IO.read tc) 32 in
    let pid = IO.read_i32 tc in
    let nmods = IO.read_i32 tc in
    let ldt_base = 
      if (_version >= 50) then (int64_of_uint32 (IO.read_real_i32 tc))
      else 0L 
    in
    let mods = List.rev (read_list [] (fun () -> read_module tc) nmods) in
      _name <- name;
      _pid <- pid;
      _modules <- mods;
      _ldt_base <- ldt_base
end

let read_process version tc =
  let pinfo = new proc_info version in
    pinfo#unserialize tc;
    pinfo

(** Class for trace interface *)
class trace_interface trace_header channel procs ireader =
object
  val _version : int = trace_header.version
  val _rawchannel : in_channel = channel
  val _iochannel : IO.input = IO.input_channel channel
  val _insn_offset : int64 = LargeFile.pos_in channel
  val _instreader : IO.input -> instruction = ireader
  val _procs : proc_info list = procs
  val _gdt_base : Libasmir.address_t = trace_header.gdt_base 
  val _idt_base : Libasmir.address_t = trace_header.idt_base 
  val mutable _idx_rawchannel : in_channel = stdin
  val mutable _idx_iochannel : IO.input = IO.input_channel stdin
  val mutable _insn_counter : int64 = 0L
  method channel = _rawchannel
  method iochannel = _iochannel
  method insn_offset = _insn_offset
  method current_offset () = LargeFile.pos_in _rawchannel

  method cleanup =
    IO.close_in _iochannel;
    IO.close_in _idx_iochannel;
    close_in_noerr _rawchannel;
    close_in_noerr _idx_rawchannel

  method processes = _procs
  method version = _version
  method set_index idx_rawchannel = 
    _idx_rawchannel <- idx_rawchannel;
    _idx_iochannel <- IO.input_channel idx_rawchannel

  method seek_instruction i =
    if _idx_rawchannel = stdin then raise No_index
    else if (i > 0L) then (
      let pos = Int64.mul (Int64.pred i) 8L in
      let _ = LargeFile.seek_in _idx_rawchannel pos in
      let offset = IO.read_i64 _idx_iochannel in
	_insn_counter <- Int64.pred i;
	LargeFile.seek_in _rawchannel offset
    )
    else
      raise (Invalid_parameter "Instruction number starts from 1")

  method num_instructions = 
    let num_insn_from_insn_size insn_size = 
      let n_procs = List.length _procs in
      let add_mods acc proc =
	(List.length proc#modules) + acc
      in
      let n_mods = List.fold_left add_mods 0 _procs in
      let header_size = Int64.of_int (12 + 40*n_procs + 40*n_mods) in
      let trace_size = LargeFile.in_channel_length _rawchannel in
      let insn_total_size = Int64.sub trace_size header_size in
      Int64.div insn_total_size insn_size
    in
    match _version with 
      | 10 -> 0L 
      | 20 -> (
          let insn_size = 2912L in
          num_insn_from_insn_size insn_size
	)
      | 30 -> (
          let insn_size = 1132L in
          num_insn_from_insn_size insn_size
	)
      | _ -> 
	  if _idx_rawchannel = stdin then 0L
	  else (
	    let size = LargeFile.in_channel_length _idx_rawchannel in
	    Int64.div size 8L
	  )

  method read_instruction =
    _insn_counter <- Int64.succ _insn_counter;
    _instreader _iochannel

  method write_header oc =
    let magicnum = Int32.of_string "0xFFFFFFFF" in
    let nprocs = List.length _procs in
      IO.write_real_i32 oc magicnum;
      IO.write_i32 oc _version;
      IO.write_i32 oc nprocs;
      if (_version >= 50) then (
	IO.write_real_i32 oc (Int64.to_int32 _gdt_base);
	IO.write_real_i32 oc (Int64.to_int32 _idt_base)
      );
      List.iter (fun proc -> proc#serialize oc) _procs

  method insn_counter = _insn_counter
end

(** Iterate over entries in a trace. Analagous to List.fold_left *)
let trace_fold f acc (tif:trace_interface) =
  let rec trace_fold_int eh_num f acc tif =
    let eh_o =
      try
        Some(tif#read_instruction)
      with
      | IO.No_more_input -> None
    in
    match eh_o with
    | None -> acc
    | Some(eh) ->
        trace_fold_int (Int64.succ eh_num) f (f acc eh eh_num) tif
  in
  trace_fold_int 1L f acc tif

(** Iterate over entries in a trace in reverse order, starting at given 
      instruction. 
  Requires a trace index for random access to the trace. 
  Raises No_index if the no index is available for the trace
*)
let trace_fold_right_from_ctr start_ctr f acc (tif:trace_interface) = 
  let rec trace_fold_rev eh_num f acc tif =
    if (eh_num <= 0L) then acc
    else (
      tif#seek_instruction eh_num;
      let eh_o =
	try
	  Some(tif#read_instruction)
	with
	| IO.No_more_input -> None
      in
      match eh_o with
      | None -> acc
      | Some(eh) -> 
	  trace_fold_rev (Int64.pred eh_num) f (f acc eh eh_num) tif
    )
  in
  trace_fold_rev start_ctr f acc tif

(** Iterate over entries in a trace in reverse order.
  Analogous to List.fold_right
  Requires a trace index for random access to the trace. 
  Raises No_index if the no index is available for the trace
*)
let trace_fold_right f acc (tif:trace_interface) =
  let num_insns = tif#num_instructions in
  trace_fold_right_from_ctr num_insns f acc (tif:trace_interface)


(** Iterate over the instructions in the trace until one of the termination 
  conditions is satisfied.
  Each termination condition is specified as an [(addr,ctr)] pair, where
    the termination condition is satisfied if address [addr] is reached 
    a number [ctr] of times.
  The instruction that first satisfies a termination condition is not 
    included in the trace.
  Values 0 and 1 for [ctr] behave identically
*)
let trace_fold_until_addr stop_l f acc (tif:trace_interface) =
  let ctr_map = Hashtbl.create 100 in
  let rec tfu eh_num f acc tif = 
    let eh_o =  
      try (
        let instr = tif#read_instruction in
        let addr = instr#address in
        try (
	  let (_,max_ctr) = List.find (fun (a,c) -> a = addr) stop_l in
	  let curr_ctr = 
	    try Hashtbl.find ctr_map addr
	    with Not_found -> 0
	  in
          let new_ctr = curr_ctr + 1 in
          Hashtbl.replace ctr_map addr new_ctr;
          if (new_ctr >= max_ctr) then None
          else Some(instr)
	)
	with Not_found -> Some(instr)
      )
      with
        | IO.No_more_input -> None
    in
      match eh_o with
        | None -> acc
        | Some(eh) ->
            tfu (Int64.succ eh_num) f (f acc eh eh_num) tif
  in
  tfu 1L f acc tif

(** Iterate over the first max_insn_ctr instructions in the trace *)
let trace_fold_until_ctr max_ctr f acc (tif:trace_interface) =
  let rec tfu eh_num f acc tif =
    let eh_o =
      (* should be >=, because the insn_counter+1 is the next
	 instruction to read *)
      if  (tif#insn_counter >= max_ctr) then None
      else (
	try
	  let instr = tif#read_instruction in
	  Some(instr)
	with
	  | IO.No_more_input -> None
      )
    in
    match eh_o with
      | None -> acc
      | Some(eh) ->
	tfu (Int64.succ eh_num) f (f acc eh eh_num) tif
  in
  tfu 1L f acc tif

(** Iterate from min_ctr to max_ctr in the trace *)
let trace_fold_from_until_ctr min_ctr max_ctr f acc (tif:trace_interface) =
  let _ = tif#seek_instruction min_ctr in
  let rec tfu eh_num f acc tif =
    let eh_o =
      (* should be >=, because the insn_counter+1 is the next
         instruction to read *)
      if  (tif#insn_counter >= max_ctr) then None
      else (
        try
          let instr = tif#read_instruction in
          Some(instr)
        with
          | IO.No_more_input -> None
      )
    in
    match eh_o with
      | None -> acc
      | Some(eh) ->
        tfu (Int64.succ eh_num) f (f acc eh eh_num) tif
  in
  tfu min_ctr f acc tif


let open_trace tname =
  let ic = open_in tname in
  let tc = IO.input_channel ic in
  let trace_hdr =
    try read_header tc
    with
	No_trace_header -> 
	  { magicnumber = 0l; version = 0; n_procs = 0;
	    gdt_base = 0L; idt_base = 0L; }
  in
  let nprocs = trace_hdr.n_procs in
  let procs = 
    List.rev (read_list [] (fun () -> read_process trace_hdr.version tc) nprocs)
  in
  let procs =
    try
      let hdric = open_in (tname ^ ".hdr") in
      let hdrtc = IO.input_channel hdric in
      let header = read_header tc in
      let nprocs = header.n_procs in
      let ver = header.version in
      let pl = 
	List.rev (read_list [] (fun () -> read_process ver hdrtc) nprocs)
      in
      let _ = IO.close_in hdrtc in
      let _ = close_in_noerr hdric in
      pl
    with
	_ -> procs
  in
  let traceifc =
    match trace_hdr.version with
	0 ->
	  let () = seek_in ic 0 in
	  let read_instruction ic =
	    let inst = new instruction_v10 in
	      inst#unserialize ic; inst
	  in
	    new trace_interface trace_hdr ic []
	      read_instruction
      | 10 ->
	  let read_instruction ic =
	    let inst = new instruction_v10 in
	      inst#unserialize ic; (inst: instruction_v10 :> instruction)
	  in
	    new trace_interface trace_hdr ic procs read_instruction
      | 20 ->
	  let read_instruction ic =
	    let inst = new instruction_v20 in
	      inst#unserialize ic; (inst: instruction_v20 :> instruction)
	  in
	    new trace_interface trace_hdr ic procs read_instruction
      | 30 ->
	  let read_instruction ic =
	    let inst = new instruction_v30 in
	      inst#unserialize ic; (inst: instruction_v30 :> instruction)
	  in
	    new trace_interface trace_hdr ic procs read_instruction
      | 40 ->
          let read_instruction ic =
            let inst = new instruction_v40 in
              inst#unserialize ic; (inst: instruction_v40 :> instruction)
          in
            new trace_interface trace_hdr ic procs read_instruction
      | 41 ->
          let read_instruction ic =
            let inst = new instruction_v41 in
              inst#unserialize ic; (inst: instruction_v41 :> instruction)
          in
            new trace_interface trace_hdr ic procs read_instruction
      | 50 ->
          let read_instruction ic =
            let inst = new instruction_v50 in
              inst#unserialize ic;
	      inst#set_gdt trace_hdr.gdt_base;
	      inst#set_idt trace_hdr.idt_base;
	      inst#set_ldt (List.hd procs)#ldt_base;
	    (inst: instruction_v50 :> instruction)
          in
            new trace_interface trace_hdr ic procs read_instruction
      | _ -> raise Unknown_trace_version
  in
  let () =
    try
      let idxfile = tname ^ ".idx" in
      let idxchannel = open_in idxfile in
	traceifc#set_index idxchannel
    with
	Sys_error(_) -> ()
  in
    traceifc


(** close trace file
    @param tc Trace file input channel
*)
let close_trace trif =
  trif#cleanup



