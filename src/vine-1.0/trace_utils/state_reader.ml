(*
Vine is Copyright (C) 2006-2009, BitBlaze Team.

You can redistribute and modify it under the terms of the GNU GPL,
version 2 or later, but it is made available WITHOUT ANY WARRANTY.
See the top-level README file for more details.

For more information about Vine and other BitBlaze software, see our
web site at: http://bitblaze.cs.berkeley.edu/
*)

(**
  A driver to read state files generated by TEMU
*)

open Vine
open Vine_util
open Temu_state

type cmdlineargs_t = {
  mutable in_state_file : string;
  mutable in_state_ranges : (int64 * int64) list;
  mutable out_meminits : string;
  mutable out_dumps_pid : int;
  mutable out_ranges_file : string;
  mutable verbose : bool;
  mutable out_raw_file : string;
} ;;

let layer_id = 0

(* Size of a memory page *)
let page_size = 4096L

(* Get the start address of the memory page containing the given address *)
let page_start addr =
  Int64.mul (Int64.div addr page_size) page_size

(* Get list of pages that comprise a range *)
let get_page_list first last =
  let first_page = page_start first in
  let rec add_page acc curr_start =
    let next_page = Int64.add curr_start page_size in
    if (next_page > last) then List.rev acc
    else add_page (next_page :: acc) next_page
  in
  add_page [first_page] first_page


(* Generate a raw dump file for each memory page in given ranges *) 
let generate_raw_dump pid state_iface ranges =
  let ranges = List.sort Pervasives.compare ranges in 
  let process_range ((first:int64), (last:int64)) =
    let page_l = get_page_list first last in
    let process_page page_start = 
      let page_end = Int64.pred (Int64.add page_start page_size) in
      let data = state_iface#get_memrange page_start page_end in
      let num_bytes = List.length data in
      (* Printf.printf "Num_bytes: %d\n"  num_bytes; *)
      (* Printf.printf "0x%08Lx -> 0x%08Lx\n" page_start page_end; *)
      if (num_bytes > 0) then (
	let filename = 
	  Printf.sprintf "dump_%d_%08Lx_%d_%08Lx.bin" 
	    pid page_start layer_id page_end
	in
	let oc = open_out filename in
	let ioc = IO.output_channel oc in
	List.iter (fun (_,b) -> IO.write ioc b) data;
	let _ = IO.close_out ioc in
	close_out oc
      )
    in
    List.iter process_page page_l;
  in
  List.iter process_range ranges


(* Parse the command line arguments *)
let parse_cmdline =
  let cmdlineargs = {
    in_state_file = "";
    in_state_ranges = [];
    out_meminits = "";
    out_dumps_pid = 0;
    out_ranges_file = "";
    verbose = false;
    out_raw_file = "";
  } 
  in
  let progname = Sys.argv.(0) in
  let usage = "USAGE: Check " ^ progname ^ " -help" in
  let add_state_range s = 
    try (
        Scanf.sscanf s "0x%Lx:0x%Lx" (fun x y -> 
          cmdlineargs.in_state_ranges <- (x,y)::cmdlineargs.in_state_ranges)
    )
    with _ -> (
      Printf.fprintf stderr "Invalid range format. Exitting...\n";
      exit 1
    )
  in
  let ignore_arg x = () in
  let rec arg_spec =
    ("-in-state", Arg.String (fun s -> cmdlineargs.in_state_file <- s),
      "<file> File containing TEMU state")
    ::("-in-state-range", Arg.String add_state_range,
      "<0xDEAD:0xBEEF> Memory range startAddr:EndAddr (inclusive)")
    ::("-out-dumps", Arg.Int (fun i -> cmdlineargs.out_dumps_pid <- i),
	"<pid> PID of the process. Generates a raw dump file per memory page")
    ::("-out-meminits", Arg.String (fun s -> cmdlineargs.out_meminits <- s),
	"<file> File to output Vine memory initializers for given ranges")
    ::("-out-ranges", Arg.String (fun s -> cmdlineargs.out_ranges_file <- s),
	"<file> File to output all ranges in state file (without content)")
    ::("-out-raw", Arg.String (fun s -> cmdlineargs.out_raw_file <- s),
	"<file> File to output raw data from first given range")
    ::("-v", Arg.Unit (fun () -> cmdlineargs.verbose <- true),
	"<> Verbose output")
    ::[]
  in
  let _ = Arg.parse arg_spec ignore_arg usage in
  cmdlineargs
;;

(* main *)
let main () =
  (* Parse arguments *)
  let args = parse_cmdline in

  (* Create a memory variable *)
  let arr_t = (Array(REG_8,(Vine.array_idx_type_to_size REG_32))) in
  let arr_name = "mem_arr" in
  let memvar = Vine.newvar arr_name arr_t in

  (* Open state file *)
  let state = 
    if (args.in_state_file <> "") then (
      try open_state args.in_state_file
      with _ -> (
	Printf.fprintf stderr "Could not open state file: %s\n" 
	  args.in_state_file;
	exit 1
      )
    )
    else (
      Printf.fprintf stderr "Need to provide state file\n";
      exit 1
    )
  in

  (* Some verbose printouts *)
  let () = 
    if (args.verbose) then (
      Printf.printf "Version: %d\n%!" state#version;
      print_regs stdout state#regs
    )
  in

  (* Output all ranges in state file *)
  if (args.out_ranges_file  <> "") then (
    let oc = open_out args.out_ranges_file in
    List.iter (fun b -> Printf.fprintf oc "0x%Lx -> 0x%Lx\n" b.first b.last) 
      state#blocks;
    exit 0;
  );

  (* Output meminits file *)
  let () = 
    if (args.out_meminits <> "") then (
      let oc = 
        try open_out args.out_meminits
        with _ -> stdout
      in
      let mem_inits_sl =
        if (List.length args.in_state_ranges >= 1)
          then state#range_inits args.in_state_ranges memvar
        else []
      in
      let mem_inits_sl = List.rev mem_inits_sl in
      let num_inits = List.length mem_inits_sl in
      if (num_inits > 0) then (
        let prog = ([memvar],mem_inits_sl) in
        Vine.pp_program (output_string oc) prog;
        if (oc <> stdout) then close_out oc
      )
      else Printf.fprintf stdout "No statements found\n";
    )
  in

  (* Output dumps files *)
  if (args.out_dumps_pid <> 0) then (
    if (List.length args.in_state_ranges >= 1) then (
      generate_raw_dump args.out_dumps_pid state args.in_state_ranges
    )
    else (
      Printf.fprintf stdout "Cannot output dumps. No memory range given\n";
      exit 1
    )
  );

  (* Output single raw file *)
  if (args.out_raw_file <> "") then (
    let oc = open_out args.out_raw_file in
    let (first,last) = List.hd args.in_state_ranges in
    let () = state#write_range oc first last in
    close_out oc
  );

  let () = close_state state in
  exit 0
;;

  main ();;

