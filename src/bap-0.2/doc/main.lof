\addvspace {10\p@ }
\contentsline {figure}{\numberline {1.1}{\ignorespaces A three instruction x86 program, and its corresponding control flow graph. Note the logic for deciding when the jump on overflow instruction (statement 3) is taken, when is often omitted by other binary analysis platforms. }}{2}{figure.1.1}
\contentsline {figure}{\numberline {1.2}{\ignorespaces The semantics of the {\tt rep} instruction according to Intel\nobreakspace {}\cite {intel:x86}. Modern architectures often have hundreds of instructions that have complex semantics like {\tt rep}.}}{3}{figure.1.2}
\contentsline {figure}{\numberline {1.3}{\ignorespaces The BAP\xspace binary analysis architecture and components. BAP\xspace is divided into a front-end, which is responsible for lifting instructions to the BAP\xspace IL, and a platform-independent back-end for analyses.}}{4}{figure.1.3}
\addvspace {10\p@ }
\contentsline {figure}{\numberline {2.1}{\ignorespaces High-level view of tools provided with BAP\xspace .}}{8}{figure.2.1}
\addvspace {10\p@ }
\contentsline {figure}{\numberline {3.1}{\ignorespaces (a) shows an example of little-endian stores as found in x86 that partially overlap. (b) shows memory after executing line 1, and (c) shows memory after executing line 5. Line 7 will load the value 0x22bb.}}{16}{figure.3.1}
\contentsline {figure}{\numberline {3.2}{\ignorespaces Normalized version of the store and load from Figure\nobreakspace {}\ref {endian:code}.}}{16}{figure.3.2}
\addvspace {10\p@ }
\addvspace {10\p@ }
\addvspace {10\p@ }
